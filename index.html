<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0,maximum-scale=1.0,user-scalable=no">
<meta name="theme-color" content="#0a0a0f">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="BS SCANNER">
<link rel="manifest" href="data:application/json;base64,eyJuYW1lIjoiQlMgUXVhbnR1bSB2MTMgU2Nhbm5lciIsInNob3J0X25hbWUiOiJCUyB2MTMiLCJkZXNjcmlwdGlvbiI6IkJ5Yml0IENyeXB0byBTaWduYWwgU2Nhbm5lciB3aXRoIE11bHRpLUFJIiwic3RhcnRfdXJsIjoiLiIsImRpc3BsYXkiOiJzdGFuZGFsb25lIiwiYmFja2dyb3VuZF9jb2xvciI6IiMwYTBhMGYiLCJ0aGVtZV9jb2xvciI6IiMwYTBhMGYiLCJpY29ucyI6W3sic3JjIjoiZGF0YTppbWFnZS9zdmcreG1sLDxzdmcgeG1sbnM9J2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyB2aWV3Qm94PScwIDAgMTAwIDEwMCc+PHJlY3Qgd2lkdGg9JzEwMCcgaGVpZ2h0PScxMDAnIGZpbGw9JyUyMzBhMGEwZicvPjx0ZXh0IHg9JzUwJyB5PSc2MCcgZm9udC1zaXplPSc0MCcgdGV4dC1hbmNob3I9J21pZGRsZScgZmlsbD0nJTIzZmZkNzAwJz7imqE8L3RleHQ+PC9zdmc+Iiwic2l6ZXMiOiIxOTJ4MTkyIiwidHlwZSI6ImltYWdlL3N2Zyt4bWwifV19">
<title>BS SCANNER - Multi-AI</title>
<style>
:root{
--bg1:#0a0a0f;--bg2:#12121a;--bg3:#1a1a25;--bg4:#22222f;
--border:#2a2a3a;--text:#ffffff;--text2:#ffffff;--text3:#ffffff;
--long:#00d9a0;--long-dim:rgba(0,217,160,0.15);
--short:#ff4757;--short-dim:rgba(255,71,87,0.15);
--purple:#a855f7;--purple-dim:rgba(168,85,247,0.15);
--blue:#3b82f6;--blue-dim:rgba(59,130,246,0.15);
--amber:#f59e0b;--amber-dim:rgba(245,158,11,0.15);
--cyan:#06b6d4;--cyan-dim:rgba(6,182,212,0.15);
--gold:#ffd700;--gold-dim:rgba(255,215,0,0.15)
}
*{margin:0;padding:0;box-sizing:border-box}
body{font-family:system-ui,-apple-system,sans-serif;background:var(--bg1);color:var(--text);min-height:100vh;overflow-x:hidden}
.app{display:flex;flex-direction:column;min-height:100vh}

/* HEADER - 2 ROW LAYOUT */
.header{display:flex;flex-direction:column;padding:8px 10px;background:var(--bg2);border-bottom:1px solid var(--border);gap:6px}
.header-row1{display:flex;align-items:center;gap:1px}
.header-row2{display:flex;align-items:center;gap:8px}
.header-btns{display:flex;gap:4px;margin-left:auto}
.btn{padding:4px 8px;border-radius:4px;border:1px solid var(--border);background:var(--bg3);color:var(--text);font-size:10px;cursor:pointer;transition:all 0.2s}
.btn:hover{background:var(--bg4)}
.btn.active{background:var(--long-dim);border-color:var(--long);color:var(--long)}
.btn.scanning{background:var(--amber-dim);border-color:var(--amber);color:var(--amber);animation:pulse 1.5s infinite}
@keyframes pulse{0%,100%{opacity:1}50%{opacity:0.6}}

/* MARKET BADGES - COMPACT */
.m-badge{display:flex;align-items:center;gap:2px;padding:3px 5px;background:var(--bg3);border-radius:4px;border:1px solid var(--border);font-size:10px}
.m-badge-icon{font-size:10px}
.m-badge-value{font-weight:700;color:var(--text);font-size:10px}
.m-badge.bull .m-badge-value{color:var(--long)}
.m-badge.bear .m-badge-value{color:var(--short)}
.m-badge.neutral .m-badge-value{color:var(--text)}
/* Season flash animations */
.m-badge.flash-bright-green{animation:flashBrightGreen 0.5s ease-in-out infinite}
.m-badge.flash-dim-green{animation:flashDimGreen 2s ease-in-out infinite}
.m-badge.flash-bright-red{animation:flashBrightRed 0.5s ease-in-out infinite}
.m-badge.flash-dim-red{animation:flashDimRed 2s ease-in-out infinite}
.m-badge.flash-bright-green .m-badge-value{color:#00ff88;text-shadow:0 0 8px #00ff88}
.m-badge.flash-dim-green .m-badge-value{color:#00d980;text-shadow:0 0 4px #00d980}
.m-badge.flash-bright-red .m-badge-value{color:#ff4757;text-shadow:0 0 8px #ff4757}
.m-badge.flash-dim-red .m-badge-value{color:#ff6b6b;text-shadow:0 0 4px #ff6b6b}
@keyframes flashBrightGreen{0%,100%{opacity:1}50%{opacity:0.3}}
@keyframes flashDimGreen{0%,100%{opacity:1}50%{opacity:0.6}}
@keyframes flashBrightRed{0%,100%{opacity:1}50%{opacity:0.3}}
@keyframes flashDimRed{0%,100%{opacity:1}50%{opacity:0.6}}

/* SCAN PROGRESS BAR - LONGER & GLOWING */
.scan-progress-bar{display:none;flex:1;align-items:center;gap:6px}
.scan-progress-bar.active{display:flex}
.scan-progress-track{flex:1;height:6px;background:var(--bg4);border-radius:3px;overflow:hidden;box-shadow:inset 0 0 3px rgba(0,0,0,0.3)}
.scan-progress-fill{height:100%;border-radius:3px;transition:width 0.3s;background:var(--amber)}
.scan-progress-fill.scanning{background:linear-gradient(90deg,#ff0000,#ff4400,#ff8800,#ffcc00,#ffff00,#88ff00,#00ff00,#00ff88,#00ffff,#0088ff,#0044ff,#4400ff,#8800ff,#ff00ff,#ff0088,#ff0044,#ff0000);background-size:200% 100%;animation:rainbowFlow 2s linear infinite;box-shadow:0 0 15px rgba(255,255,255,0.5),0 0 30px rgba(0,255,255,0.3),0 0 45px rgba(255,0,255,0.2)}
.scan-progress-fill.done{background:linear-gradient(90deg,var(--long),#00ffaa,var(--cyan),#00ffaa,var(--long));background-size:200% 100%;animation:completePulse 3s ease-in-out infinite;box-shadow:0 0 20px var(--long),0 0 40px rgba(0,255,170,0.4)}
.scan-progress-fill.error{background:linear-gradient(90deg,var(--short),#ff6b6b,#ff4757,#ff6b6b,var(--short));background-size:200% 100%;animation:errorPulse 1.5s ease-in-out infinite;box-shadow:0 0 20px var(--short),0 0 40px rgba(255,71,87,0.4)}
@keyframes errorPulse{0%,100%{background-position:0% 50%;box-shadow:0 0 15px var(--short)}50%{background-position:100% 50%;box-shadow:0 0 30px var(--short)}}
.scan-progress-text.error{color:var(--short)}
.scan-progress-pct.error{color:var(--short)}
@keyframes rainbowFlow{0%{background-position:0% 50%}100%{background-position:200% 50%}}
@keyframes completePulse{0%,100%{background-position:0% 50%;box-shadow:0 0 20px var(--long)}50%{background-position:100% 50%;box-shadow:0 0 40px var(--long),0 0 60px var(--cyan)}}
.scan-progress-text{font-size:10px;color:var(--amber);white-space:nowrap}
.scan-progress-text.done{color:var(--long)}
@keyframes scanGlow{0%,100%{box-shadow:0 0 10px var(--amber),0 0 20px rgba(247,166,0,0.5)}50%{box-shadow:0 0 15px var(--amber),0 0 30px rgba(247,166,0,0.7)}}

/* GLOW RADAR ICON */
.glow-radar{color:var(--gold);text-shadow:0 0 10px var(--gold),0 0 20px var(--gold),0 0 30px rgba(255,215,0,0.5);animation:radarPulse 2s ease-in-out infinite}
@keyframes radarPulse{0%,100%{transform:scale(1);opacity:1}50%{transform:scale(1.1);opacity:0.8}}

/* CONTENT LAYOUT */
.content{display:flex;flex-direction:column;flex:1}
@media(min-width:900px){.content{flex-direction:row}.sidebar{width:380px;border-right:1px solid var(--border)}.main{flex:1}}
.sidebar{background:var(--bg2);display:flex;flex-direction:column;max-height:55vh}
@media(min-width:900px){.sidebar{max-height:none;height:calc(100vh - 52px)}}

/* SIDEBAR TOP */
.sidebar-top{padding:10px;border-bottom:1px solid var(--border)}
.mode-row{display:flex;gap:4px;margin-bottom:8px}
.mode-btn{flex:1;padding:8px 4px;border:1px solid var(--border);border-radius:5px;background:transparent;color:var(--text2);font-size:11px;font-weight:600;cursor:pointer;transition:all 0.2s}
.mode-btn.active{background:var(--purple);border-color:var(--purple);color:white}
.mode-btn:hover:not(.active){background:var(--bg4)}
.filter-row{display:flex;gap:4px}
.filter-btn{flex:1;padding:6px 4px;border:1px solid var(--border);border-radius:4px;background:transparent;color:var(--text3);font-size:12px;cursor:pointer;transition:all 0.2s}
.filter-btn.active{background:var(--bg4);color:var(--text);border-color:var(--text3)}
.filter-btn .count{margin-left:3px;color:var(--cyan)}

/* SIGNAL LIST */
.signal-list{flex:1;overflow-y:auto;padding:8px}
.signal-card{background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:10px;margin-bottom:8px;cursor:pointer;transition:all 0.3s}
.signal-card:hover{transform:translateX(2px)}
.signal-card.active{border-color:var(--gold);background:var(--gold-dim)}

/* GLOWING EFFECTS - LONG/SHORT */
.signal-card.long{border-left:3px solid var(--long);box-shadow:0 0 12px rgba(0,217,160,0.2),inset 0 0 20px rgba(0,217,160,0.05)}
.signal-card.long:hover{box-shadow:0 0 20px rgba(0,217,160,0.4),inset 0 0 30px rgba(0,217,160,0.1)}
.signal-card.short{border-left:3px solid var(--short);box-shadow:0 0 12px rgba(255,71,87,0.2),inset 0 0 20px rgba(255,71,87,0.05)}
.signal-card.short:hover{box-shadow:0 0 20px rgba(255,71,87,0.4),inset 0 0 30px rgba(255,71,87,0.1)}

/* GLOWING GRADE BADGES */
.signal-card.long.grade-perfect{box-shadow:0 0 15px rgba(0,217,160,0.3),0 0 25px rgba(255,215,0,0.3)}
.signal-card.short.grade-perfect{box-shadow:0 0 15px rgba(255,71,87,0.3),0 0 25px rgba(255,215,0,0.3)}
.signal-card.long.grade-strong{box-shadow:0 0 15px rgba(0,217,160,0.35)}
.signal-card.short.grade-strong{box-shadow:0 0 15px rgba(255,71,87,0.35)}
.signal-card.long.grade-valid{box-shadow:0 0 12px rgba(0,217,160,0.25),0 0 20px rgba(59,130,246,0.2)}
.signal-card.short.grade-valid{box-shadow:0 0 12px rgba(255,71,87,0.25),0 0 20px rgba(59,130,246,0.2)}
.signal-card.long.grade-heating{box-shadow:0 0 10px rgba(0,217,160,0.2),0 0 15px rgba(245,158,11,0.2)}
.signal-card.short.grade-heating{box-shadow:0 0 10px rgba(255,71,87,0.2),0 0 15px rgba(245,158,11,0.2)}
.signal-card.grade-brewing{box-shadow:0 0 8px rgba(168,85,247,0.15)}

/* 3/3 AGREEMENT EXTRA GLOW */
.signal-card.full-agree{animation:pulseGlow 2s ease-in-out infinite}
@keyframes pulseGlow{0%,100%{filter:brightness(1)}50%{filter:brightness(1.1)}}

.signal-top{display:flex;justify-content:space-between;align-items:center;margin-bottom:6px}
.signal-pair{font-weight:700;font-size:14px;display:flex;align-items:center;gap:5px}
.dir-tag{font-size:12px;font-weight:700;padding:2px 6px;border-radius:3px}
.dir-tag.long{background:var(--long-dim);color:var(--long);box-shadow:0 0 8px rgba(0,217,160,0.3)}
.dir-tag.short{background:var(--short-dim);color:var(--short);box-shadow:0 0 8px rgba(255,71,87,0.3)}
.tf-tag{font-size:12px;padding:2px 6px;border-radius:3px;background:var(--bg4);border:1px solid var(--cyan);color:var(--cyan)}

/* GLOWING GRADE BADGES */
.grade{font-size:12px;font-weight:700;padding:4px 8px;border-radius:4px}
.grade.perfect{background:linear-gradient(135deg,var(--gold),#ffaa00);color:#000;box-shadow:0 0 15px rgba(255,215,0,0.5);animation:goldPulse 1.5s ease-in-out infinite}
@keyframes goldPulse{0%,100%{box-shadow:0 0 15px rgba(255,215,0,0.5)}50%{box-shadow:0 0 25px rgba(255,215,0,0.8)}}
.grade.strong{background:var(--long);color:#000;box-shadow:0 0 12px rgba(0,217,160,0.4)}
.grade.valid{background:var(--blue);color:white;box-shadow:0 0 10px rgba(59,130,246,0.4)}
.grade.heating{background:var(--amber);color:#000;box-shadow:0 0 10px rgba(245,158,11,0.4)}
.grade.brewing{background:var(--purple-dim);color:var(--purple);border:1px solid var(--purple);box-shadow:0 0 8px rgba(168,85,247,0.3)}
.signal-meta{display:flex;gap:6px;font-size:12px;color:var(--text2);margin-bottom:5px}
.signal-scores{display:flex;gap:3px;flex-wrap:wrap}
.score-tag{font-size:12px;padding:2px 5px;border-radius:3px;background:var(--bg4);color:var(--text2);font-family:monospace}
.score-tag.good{color:var(--long);text-shadow:0 0 5px rgba(0,217,160,0.5)}
.score-tag.mid{color:var(--amber);text-shadow:0 0 5px rgba(245,158,11,0.5)}
.score-tag.low{color:var(--short);text-shadow:0 0 5px rgba(255,71,87,0.5)}

/* STATUS BADGES */
.status-badge{font-size:11px;font-weight:700;padding:2px 5px;border-radius:3px;margin-left:4px}
.status-badge.new{background:var(--cyan-dim);color:var(--cyan);box-shadow:0 0 8px rgba(6,182,212,0.4)}
.status-badge.up{background:var(--long-dim);color:var(--long)}
.status-badge.down{background:var(--short-dim);color:var(--short)}
.status-badge.gone{background:var(--bg4);color:var(--text3);text-decoration:line-through}

/* MAIN PANEL */
.main{padding:12px;overflow-y:auto;background:var(--bg1)}
@media(min-width:900px){.main{height:calc(100vh - 52px)}}
.detail-box{background:var(--bg2);border:1px solid var(--border);border-radius:10px;padding:14px}
.detail-header{display:flex;justify-content:space-between;align-items:center;padding-bottom:12px;border-bottom:1px solid var(--border);margin-bottom:12px;flex-wrap:wrap;gap:8px}
.detail-title{display:flex;align-items:center;gap:8px;flex-wrap:wrap}
.detail-pair{font-size:22px;font-weight:700}
.detail-price{text-align:right}
.detail-price-label{font-size:12px;color:var(--text2)}
.detail-price-value{font-size:18px;font-weight:700;font-family:monospace}

/* HTF BOX */
.htf-box{background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:10px;margin-bottom:12px}
.htf-title{font-size:11px;color:var(--text2);margin-bottom:8px;display:flex;align-items:center;gap:6px}
.htf-grid{display:grid;grid-template-columns:repeat(4,1fr);gap:6px}
.htf-item{text-align:center;padding:6px 4px;background:var(--bg4);border-radius:5px}
.htf-label{font-size:12px;color:var(--text3)}
.htf-value{font-size:11px;font-weight:700}
.htf-value.bull{color:var(--long)}
.htf-value.bear{color:var(--short)}
.htf-value.neutral{color:var(--text3)}

/* AI SECTION */
.ai-section{background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:14px;margin-bottom:12px}
.ai-header{display:flex;justify-content:space-between;align-items:center;margin-bottom:10px}
.ai-title{font-size:13px;font-weight:700;display:flex;align-items:center;gap:6px}
.ai-verdict{font-size:11px;font-weight:700;padding:4px 12px;border-radius:4px}
.ai-verdict.take{background:var(--long-dim);color:var(--long)}
.ai-verdict.skip{background:var(--short-dim);color:var(--short)}
.ai-verdict.wait{background:var(--amber-dim);color:var(--amber)}
.ai-bar{height:8px;background:var(--bg2);border-radius:4px;overflow:hidden;margin-bottom:8px}
.ai-fill{height:100%;border-radius:4px;transition:width 0.3s}
.ai-text{font-size:11px;color:var(--text2);line-height:1.5;margin-bottom:8px}
.ai-risks{font-size:12px;color:var(--amber);margin-bottom:8px}
.ai-btn{width:100%;padding:10px;background:linear-gradient(135deg,#f55036,#ff6b4a);border:none;color:white;border-radius:6px;font-size:12px;font-weight:700;cursor:pointer}
.ai-btn:hover{opacity:0.9}

/* ANALYSIS GRID */
.analysis-grid{display:grid;grid-template-columns:1fr;gap:10px;margin-bottom:12px}
@media(min-width:600px){.analysis-grid{grid-template-columns:repeat(3,1fr)}}
.analysis-card{background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:12px}
.analysis-head{display:flex;justify-content:space-between;align-items:center;margin-bottom:8px}
.analysis-title{font-size:11px;color:var(--text2)}
.analysis-score{font-family:monospace;font-weight:700;padding:3px 8px;border-radius:4px;font-size:12px}
.analysis-row{display:flex;justify-content:space-between;font-size:12px;padding:3px 0;border-bottom:1px solid var(--border)}
.analysis-row:last-child{border-bottom:none}
.analysis-label{color:var(--text2)}
.analysis-value{font-family:monospace;font-weight:600}
.factor-list{display:flex;flex-wrap:wrap;gap:3px;margin-top:8px}
.factor{font-size:12px;padding:2px 5px;border-radius:3px;background:var(--bg4);color:var(--text2)}
.factor.bull{background:var(--long-dim);color:var(--long)}
.factor.bear{background:var(--short-dim);color:var(--short)}
.factor.warn{background:var(--amber-dim);color:var(--amber)}

/* TRADE SECTION */
.trade-section{margin-bottom:12px}
.trade-title{font-size:12px;font-weight:600;margin-bottom:10px;color:var(--text2)}
.trade-grid{display:grid;grid-template-columns:repeat(5,1fr);gap:6px}
@media(max-width:500px){.trade-grid{grid-template-columns:repeat(3,1fr)}}
.trade-box{background:var(--bg3);border:1px solid var(--border);border-radius:6px;padding:8px 4px;text-align:center}
.trade-box-label{font-size:12px;color:var(--text3);margin-bottom:2px}
.trade-box-value{font-family:monospace;font-size:12px;font-weight:600;word-break:break-all}
.trade-box.entry{border-color:var(--cyan)}.trade-box.entry .trade-box-value{color:var(--cyan)}
.trade-box.limit{border-color:var(--purple);background:var(--purple-dim)}.trade-box.limit .trade-box-value{color:var(--purple)}
.trade-box.limit .limit-type{font-size:9px;color:var(--purple);font-weight:700;margin-top:2px}
.trade-box.sl{border-color:var(--short)}.trade-box.sl .trade-box-value{color:var(--short)}
.trade-box.tp{border-color:var(--long)}.trade-box.tp .trade-box-value{color:var(--long)}
.trade-meta{display:flex;justify-content:space-between;align-items:center;margin-top:10px}
.rr-tag{background:var(--purple-dim);color:var(--purple);padding:5px 12px;border-radius:5px;font-size:11px;font-weight:600}
.track-btn{padding:10px 20px;background:var(--amber-dim);border:1px solid var(--amber);color:var(--amber);border-radius:6px;font-size:12px;font-weight:600;cursor:pointer}
.track-btn:hover{background:var(--amber);color:#000}

/* ACTIVE TRADES */
.active-section{border-top:1px solid var(--border);padding:10px;background:var(--bg1)}
.active-title{font-size:11px;font-weight:700;margin-bottom:8px;display:flex;align-items:center;gap:6px}
.active-count{background:var(--purple);color:white;font-size:12px;padding:2px 6px;border-radius:8px}
.active-list{max-height:150px;overflow-y:auto}
.active-card{background:var(--bg3);border:1px solid var(--border);border-radius:6px;padding:8px;margin-bottom:6px}
.active-card.long{border-left:3px solid var(--long)}
.active-card.short{border-left:3px solid var(--short)}
.active-top{display:flex;justify-content:space-between;align-items:center;margin-bottom:4px}
.active-pair{font-weight:700;font-size:12px;display:flex;align-items:center;gap:5px}
.active-pnl{font-family:monospace;font-size:11px;font-weight:700;padding:2px 6px;border-radius:4px}
.active-pnl.profit{background:var(--long-dim);color:var(--long)}
.active-pnl.loss{background:var(--short-dim);color:var(--short)}
.active-levels{display:grid;grid-template-columns:repeat(5,1fr);gap:3px;margin-bottom:4px}
.active-level{text-align:center;padding:3px;background:var(--bg4);border-radius:3px}
.active-level-label{font-size:11px;color:var(--text3)}
.active-level-value{font-family:monospace;font-size:12px}
.active-level.hit{background:var(--long-dim);border:1px solid var(--long)}
.active-level.stopped{background:var(--short-dim);border:1px solid var(--short)}
.active-meta{display:flex;justify-content:space-between;align-items:center;font-size:12px;color:var(--text3)}
.close-btn{padding:3px 8px;background:var(--bg4);border:1px solid var(--border);color:var(--text2);border-radius:3px;font-size:12px;cursor:pointer}
.close-btn:hover{background:var(--short-dim);border-color:var(--short);color:var(--short)}

/* EMPTY & LOADING */
.empty{text-align:center;padding:40px 20px;color:var(--text2)}
.empty-icon{font-size:36px;margin-bottom:10px}
.spinner{width:24px;height:24px;border:3px solid var(--bg4);border-top-color:var(--gold);border-radius:50%;animation:spin 0.8s linear infinite;margin:0 auto 10px}
@keyframes spin{to{transform:rotate(360deg)}}
.scan-status{font-size:12px;color:var(--text3);margin-top:6px}

/* MODAL */
.modal-bg{position:fixed;top:0;left:0;right:0;bottom:0;background:rgba(0,0,0,0.85);display:none;align-items:center;justify-content:center;z-index:1000;padding:10px}
.modal-bg.show{display:flex}
.modal{background:var(--bg2);border:1px solid var(--border);border-radius:12px;width:100%;max-width:500px;max-height:90vh;overflow:hidden}
.modal-head{display:flex;justify-content:space-between;align-items:center;padding:12px 14px;border-bottom:1px solid var(--border)}
.modal-title{font-size:14px;font-weight:700}
.modal-close{background:none;border:none;color:var(--text2);font-size:22px;cursor:pointer}
.modal-body{padding:14px;overflow-y:auto;max-height:60vh}
.form-group{margin-bottom:12px}
.form-label{font-size:12px;color:var(--text2);margin-bottom:4px;display:block}
.form-input,.form-select{width:100%;padding:10px;background:var(--bg4);border:1px solid var(--border);border-radius:6px;color:var(--text);font-size:12px}
.form-row{display:flex;gap:8px;margin-top:6px}
.form-row .btn{flex:1}
.key-status{font-size:12px;padding:6px 10px;border-radius:5px;margin-bottom:12px}
.key-status.valid{background:var(--long-dim);color:var(--long)}
.key-status.invalid{background:var(--short-dim);color:var(--short)}
.modal-foot{padding:12px 14px;border-top:1px solid var(--border);display:flex;justify-content:flex-end;gap:8px}
.groq-info{background:var(--cyan-dim);border:1px solid var(--cyan);border-radius:6px;padding:10px;font-size:11px;color:var(--cyan);margin-bottom:12px}
.groq-info a{color:var(--cyan)}

/* TIMEFRAME & ALERT TOGGLES */
.tf-toggle{display:flex;align-items:center;justify-content:center;padding:10px;background:var(--bg4);border:1px solid var(--border);border-radius:6px;cursor:pointer;transition:all 0.2s}
.tf-toggle:has(input:checked){background:var(--long-dim);border-color:var(--long)}
.tf-toggle input{display:none}
.tf-toggle-label{font-size:13px;font-weight:700;color:var(--text)}
.tf-toggle:has(input:checked) .tf-toggle-label{color:var(--long)}
.alert-toggle{display:flex;align-items:center;gap:10px;padding:10px;background:var(--bg4);border:1px solid var(--border);border-radius:6px;cursor:pointer;margin-bottom:8px}
.alert-toggle:has(input:checked){background:var(--amber-dim);border-color:var(--amber)}
.alert-toggle input{width:18px;height:18px;accent-color:var(--amber)}
.alert-toggle-label{font-size:12px;color:var(--text)}

/* TOAST */
.toast-box{position:fixed;bottom:12px;right:12px;z-index:1100}
.toast{background:var(--bg3);border:1px solid var(--border);border-radius:6px;padding:10px 14px;margin-top:6px;font-size:12px;animation:slideIn 0.3s}
.toast.success{border-color:var(--long);background:var(--long-dim)}
.toast.error{border-color:var(--short);background:var(--short-dim)}
.toast.warning{border-color:var(--amber);background:var(--amber-dim)}
@keyframes slideIn{from{opacity:0;transform:translateX(30px)}to{opacity:1;transform:translateX(0)}}

/* DASHBOARD STATS BAR */
.stats-bar{display:grid;grid-template-columns:repeat(5,1fr);gap:4px;padding:8px;background:var(--bg2);border-bottom:1px solid var(--border)}
.stat-box{text-align:center;padding:6px 4px;background:var(--bg3);border-radius:6px;border:1px solid var(--border)}
.stat-value{font-size:16px;font-weight:700;font-family:monospace}
.stat-value.long{color:var(--long);text-shadow:0 0 8px rgba(0,217,160,0.4)}
.stat-value.short{color:var(--short);text-shadow:0 0 8px rgba(255,71,87,0.4)}
.stat-value.gold{color:var(--gold);text-shadow:0 0 8px rgba(255,215,0,0.4)}
.stat-label{font-size:10px;color:var(--text3);margin-top:2px}

/* COIN MANAGER */
.coin-manager{max-height:200px;overflow-y:auto;border:1px solid var(--border);border-radius:6px;padding:8px;background:var(--bg4)}
.coin-grid{display:flex;flex-wrap:wrap;gap:4px}
.coin-chip{display:flex;align-items:center;gap:4px;padding:4px 8px;background:var(--bg3);border:1px solid var(--border);border-radius:4px;font-size:11px;font-weight:600}
.coin-chip .remove-coin{cursor:pointer;color:var(--short);font-weight:700}
.coin-chip .remove-coin:hover{color:#ff0000}
.add-coin-row{display:flex;gap:6px;margin-bottom:8px}
.add-coin-row input{flex:1;padding:8px;background:var(--bg4);border:1px solid var(--border);border-radius:4px;color:var(--text);font-size:12px;text-transform:uppercase}

/* HEAT MAP */
.heat-map-container{padding:8px;overflow-x:auto}
.heat-map-table{width:100%;border-collapse:collapse;font-size:11px}
.heat-map-table th{padding:6px 4px;background:var(--bg3);color:var(--text2);font-weight:600;border:1px solid var(--border);position:sticky;top:0}
.heat-map-table td{padding:4px;text-align:center;border:1px solid var(--border);cursor:pointer;transition:all 0.2s}
.heat-map-table td:hover{transform:scale(1.1);z-index:10}
.heat-map-table .coin-name{text-align:left;font-weight:600;background:var(--bg3);position:sticky;left:0}
.heat-cell{border-radius:4px;padding:4px 2px;font-weight:700;font-size:10px}
.heat-cell.long{background:var(--long-dim);color:var(--long);box-shadow:inset 0 0 10px rgba(0,217,160,0.3)}
.heat-cell.short{background:var(--short-dim);color:var(--short);box-shadow:inset 0 0 10px rgba(255,71,87,0.3)}
.heat-cell.none{background:var(--bg4);color:var(--text3)}
.heat-cell.perfect{box-shadow:0 0 8px rgba(255,215,0,0.5)}

/* RISK CALCULATOR */
.risk-calc{background:var(--bg3);border:1px solid var(--border);border-radius:8px;padding:12px;margin-bottom:12px}
.risk-row{display:grid;grid-template-columns:1fr 1fr;gap:8px;margin-bottom:8px}
.risk-input{padding:8px;background:var(--bg4);border:1px solid var(--border);border-radius:4px;color:var(--text);font-size:12px;width:100%}
.risk-result{background:var(--long-dim);border:1px solid var(--long);border-radius:6px;padding:10px;text-align:center}
.risk-result-value{font-size:18px;font-weight:700;color:var(--long)}
.risk-result-label{font-size:11px;color:var(--text2)}

/* SIGNAL HISTORY */
.history-list{max-height:200px;overflow-y:auto}
.history-item{display:flex;justify-content:space-between;align-items:center;padding:8px;background:var(--bg3);border-radius:6px;margin-bottom:6px;border-left:3px solid var(--border)}
.history-item.win{border-left-color:var(--long);background:var(--long-dim)}
.history-item.loss{border-left-color:var(--short);background:var(--short-dim)}
.history-item.pending{border-left-color:var(--amber)}
.history-pnl{font-weight:700;font-family:monospace}
.history-pnl.profit{color:var(--long)}
.history-pnl.loss{color:var(--short)}

/* WEIGHT SLIDERS */
.weight-slider{margin-bottom:12px}
.weight-slider-header{display:flex;justify-content:space-between;margin-bottom:4px}
.weight-slider-label{font-size:12px;color:var(--text2)}
.weight-slider-value{font-size:12px;font-weight:700;color:var(--cyan)}
.weight-slider input[type="range"]{width:100%;height:6px;background:var(--bg4);border-radius:3px;outline:none;-webkit-appearance:none}
.weight-slider input[type="range"]::-webkit-slider-thumb{-webkit-appearance:none;width:16px;height:16px;background:var(--cyan);border-radius:50%;cursor:pointer;box-shadow:0 0 8px rgba(6,182,212,0.5)}

/* VIEW TOGGLE */
.view-toggle{display:flex;gap:4px;margin-bottom:8px}
.view-btn{flex:1;padding:8px;border:1px solid var(--border);border-radius:4px;background:var(--bg4);color:var(--text3);font-size:12px;cursor:pointer;transition:all 0.2s}
.view-btn.active{background:var(--cyan-dim);border-color:var(--cyan);color:var(--cyan)}

/* OLED THEME */
body.oled{--bg1:#000000;--bg2:#050505;--bg3:#0a0a0a;--bg4:#111111;--border:#1a1a1a}
</style>
</head>
<body>
<div class="app">
<header class="header">
<!-- ROW 1: 7 Badges -->
<div class="header-row1">
<div class="m-badge" id="badgeBTC" title="BTC Price"><span class="m-badge-icon">‚Çø</span><span class="m-badge-value" id="badgeBTCVal">---</span></div>
<div class="m-badge" id="badgeDXY" title="DXY Index"><span class="m-badge-icon">üíµ</span><span class="m-badge-value" id="badgeDXYVal">---</span></div>
<div class="m-badge" id="badgeFG" title="Fear & Greed"><span class="m-badge-icon">üò±</span><span class="m-badge-value" id="badgeFGVal">--</span></div>
<div class="m-badge" id="badgeFund" title="Funding Rate"><span class="m-badge-icon">üí∞</span><span class="m-badge-value" id="badgeFundVal">--</span></div>
<div class="m-badge" id="badgeDom" title="BTC Dominance"><span class="m-badge-icon">üî•</span><span class="m-badge-value" id="badgeDomVal">--</span></div>
<div class="m-badge" id="badgeSeason" title="Alt/BTC Season"><span class="m-badge-icon" id="badgeSeasonIcon">üåô</span><span class="m-badge-value" id="badgeSeasonVal">--</span></div>
<div class="m-badge" id="badgeSession" title="Trading Session"><span class="m-badge-icon">üåç</span><span class="m-badge-value" id="badgeSessionVal">---</span></div>
</div>
<!-- ROW 2: Scan Progress Bar + Buttons -->
<div class="header-row2">
<div class="scan-progress-bar active" id="scanProgressBar">
    <span class="scan-progress-text" id="scanProgressText">Ready</span>
    <div class="scan-progress-track"><div class="scan-progress-fill" id="scanProgressFill" style="width:0%"></div></div>
    <span class="scan-progress-text" id="scanProgressPct">0%</span>
</div>
<div class="header-btns">
<button class="btn active" id="scanBtn" onclick="toggleScan()"><span id="scanIcon">‚óè</span> Scan</button>
<button class="btn" onclick="showSettings()">‚öô</button>
</div>
</div>
</header>

<!-- DASHBOARD STATS BAR -->
<div class="stats-bar">
    <div class="stat-box" onclick="filterByStats('all')" style="cursor:pointer"><div class="stat-value" id="statTotal">0</div><div class="stat-label">Signals</div></div>
    <div class="stat-box" onclick="filterByStats('perfect')" style="cursor:pointer"><div class="stat-value gold" id="statPerfect">0</div><div class="stat-label">Perfect</div></div>
    <div class="stat-box" onclick="filterByStats('long')" style="cursor:pointer"><div class="stat-value long" id="statLong">0</div><div class="stat-label">Longs</div></div>
    <div class="stat-box" onclick="filterByStats('short')" style="cursor:pointer"><div class="stat-value short" id="statShort">0</div><div class="stat-label">Shorts</div></div>
    <div class="stat-box" onclick="filterByStats('agree3')" style="cursor:pointer"><div class="stat-value" id="statFullAgree">0</div><div class="stat-label">3/3</div></div>
</div>

<div class="content">
<aside class="sidebar">
<div class="sidebar-top">
<!-- VIEW TOGGLE -->
<div class="view-toggle">
    <button class="view-btn active" id="viewList" onclick="setView('list')">üìã List</button>
    <button class="view-btn" id="viewHeatmap" onclick="setView('heatmap')">üå°Ô∏è Heat Map</button>
</div>
<div class="mode-row">
<button class="mode-btn active" id="modeAll" onclick="setMode('ALL')">ALL</button>
<button class="mode-btn" id="modeScalp" onclick="setMode('SCALP')">SCALP</button>
<button class="mode-btn" id="modeSwing" onclick="setMode('SWING')">SWING</button>
</div>
<div class="filter-row">
<button class="filter-btn active" id="filterAll" onclick="setFilter('all')">All<span class="count" id="cAll">0</span></button>
<button class="filter-btn" id="filterPerfect" onclick="setFilter('perfect')">üî•<span class="count" id="cPerfect">0</span></button>
<button class="filter-btn" id="filterReady" onclick="setFilter('ready')">Ready<span class="count" id="cReady">0</span></button>
<button class="filter-btn" id="filterEarly" onclick="setFilter('early')">Early<span class="count" id="cEarly">0</span></button>
</div>
</div>
<div class="signal-list" id="signalList"><div class="empty"><div class="spinner"></div>Initializing...</div></div>
<div class="active-section">
<div class="active-title">üìå Active Trades <span class="active-count" id="activeCount">0</span></div>
<div class="active-list" id="activeList"><div style="text-align:center;color:var(--text3);font-size:12px;padding:8px">No active trades</div></div>
</div>
</aside>
<main class="main" id="mainPanel"><div class="empty"><div class="empty-icon glow-radar">üì°</div>Select a signal to view details</div></main>
</div>
</div>

<!-- SETTINGS MODAL -->
<div class="modal-bg" id="settingsModal">
<div class="modal" style="max-height:90vh;overflow-y:auto">
<div class="modal-head"><span class="modal-title">‚öôÔ∏è Settings</span><button class="modal-close" onclick="hideSettings()">√ó</button></div>
<div class="modal-body">

<!-- AI SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin-bottom:10px;border-bottom:1px solid var(--border);padding-bottom:6px">ü§ñ AI Configuration (v13 Multi-AI)</div>
<div id="keyStatus" class="key-status valid">‚úÖ Multi-AI System Ready</div>
<div class="groq-info">üß† v13 uses 3 AI providers with auto-failover: Groq ‚Üí DeepSeek ‚Üí Gemini</div>

<!-- Groq Keys -->
<div class="form-group">
<label class="form-label">üü¢ Groq API Key (Primary - FREE)</label>
<input type="password" class="form-input" id="apiKeyInput" placeholder="gsk_...">
<div style="font-size:10px;color:var(--text3);margin-top:4px">Get free key: <a href="https://console.groq.com/keys" target="_blank" style="color:var(--cyan)">console.groq.com/keys</a></div>
</div>

<!-- DeepSeek Key -->
<div class="form-group">
<label class="form-label">üîµ DeepSeek API Key (Backup - Paid)</label>
<input type="password" class="form-input" id="deepseekKeyInput" placeholder="sk-...">
<div style="font-size:10px;color:var(--text3);margin-top:4px">Best value: <a href="https://platform.deepseek.com" target="_blank" style="color:var(--cyan)">platform.deepseek.com</a> (~$0.14/1M tokens)</div>
</div>

<!-- Gemini Key -->
<div class="form-group">
<label class="form-label">üü£ Gemini API Key (Backup - FREE)</label>
<input type="password" class="form-input" id="geminiKeyInput" placeholder="AIza...">
<div style="font-size:10px;color:var(--text3);margin-top:4px">Free backup: <a href="https://aistudio.google.com/apikey" target="_blank" style="color:var(--cyan)">aistudio.google.com/apikey</a></div>
</div>

<div class="form-row">
<button class="btn" onclick="toggleKeyVis()">üëÅÔ∏è Show</button>
<button class="btn" onclick="clearKey()">üóëÔ∏è Clear All</button>
<button class="btn" onclick="testKey()">üîå Test AI</button>
</div>

<div class="form-group">
<label class="form-label">AI Model (Groq)</label>
<select class="form-select" id="aiModelSelect">
<option value="llama-3.3-70b-versatile">Llama 3.3 70B (Best)</option>
<option value="llama-3.1-8b-instant">Llama 3.1 8B (Fast)</option>
<option value="mixtral-8x7b-32768">Mixtral 8x7B</option>
<option value="gemma2-9b-it">Gemma 2 9B</option>
</select>
</div>

<!-- COIN SELECTION SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">ü™ô Coin Selection</div>
<div style="display:flex;gap:6px;margin-bottom:10px">
<button class="btn" onclick="setCoinCount(50)">Top 50</button>
<button class="btn" onclick="setCoinCount(100)">Top 100</button>
<button class="btn" onclick="setCoinCount(150)">Top 150</button>
<button class="btn" onclick="setCoinCount(200)">Top 200</button>
</div>
<div class="add-coin-row">
<input type="text" id="addCoinInput" placeholder="Add coin (e.g. TRUMP)" maxlength="15">
<button class="btn" onclick="addCoin()">‚ûï Add</button>
</div>
<div style="font-size:11px;color:var(--text3);margin-bottom:6px">Selected: <span id="coinCountDisplay">50</span> coins (Click √ó to remove)</div>
<div class="coin-manager" id="coinManager"></div>

<!-- WEIGHT SLIDERS SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">‚öñÔ∏è Engine Weights</div>
<div class="weight-slider">
<div class="weight-slider-header"><span class="weight-slider-label">Zone Analysis</span><span class="weight-slider-value" id="weightZoneVal">35%</span></div>
<input type="range" min="10" max="60" value="35" id="weightZone" oninput="updateWeightDisplay()">
</div>
<div class="weight-slider">
<div class="weight-slider-header"><span class="weight-slider-label">SMC Analysis</span><span class="weight-slider-value" id="weightSMCVal">35%</span></div>
<input type="range" min="10" max="60" value="35" id="weightSMC" oninput="updateWeightDisplay()">
</div>
<div class="weight-slider">
<div class="weight-slider-header"><span class="weight-slider-label">Momentum Analysis</span><span class="weight-slider-value" id="weightMomentumVal">30%</span></div>
<input type="range" min="10" max="60" value="30" id="weightMomentum" oninput="updateWeightDisplay()">
</div>
<div style="font-size:11px;color:var(--text3);text-align:center;margin-top:4px">Total: <span id="weightTotal">100%</span></div>

<!-- RISK CALCULATOR SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">üí∞ Risk Management</div>
<div class="risk-row">
<div class="form-group" style="margin:0">
<label class="form-label">Account Size ($)</label>
<input type="number" class="risk-input" id="riskAccount" value="1000" placeholder="1000">
</div>
<div class="form-group" style="margin:0">
<label class="form-label">Risk Per Trade (%)</label>
<input type="number" class="risk-input" id="riskPercent" value="2" min="0.5" max="10" step="0.5" placeholder="2">
</div>
</div>
<div class="risk-row">
<div class="form-group" style="margin:0">
<label class="form-label">Default Leverage</label>
<select class="form-select" id="riskLeverage">
<option value="3">3x</option>
<option value="5">5x</option>
<option value="10" selected>10x</option>
<option value="20">20x</option>
</select>
</div>
<div class="form-group" style="margin:0">
<label class="form-label">Max Position ($)</label>
<input type="number" class="risk-input" id="riskMaxPosition" value="500" placeholder="500">
</div>
</div>

<!-- TIMEFRAME SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">‚è±Ô∏è Timeframes to Scan</div>
<div style="display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-bottom:12px">
<label class="tf-toggle"><input type="checkbox" id="tf5m" checked><span class="tf-toggle-label">5m</span></label>
<label class="tf-toggle"><input type="checkbox" id="tf15m" checked><span class="tf-toggle-label">15m</span></label>
<label class="tf-toggle"><input type="checkbox" id="tf30m" checked><span class="tf-toggle-label">30m</span></label>
<label class="tf-toggle"><input type="checkbox" id="tf1h" checked><span class="tf-toggle-label">1H</span></label>
<label class="tf-toggle"><input type="checkbox" id="tf4h" checked><span class="tf-toggle-label">4H</span></label>
<label class="tf-toggle"><input type="checkbox" id="tf1d" checked><span class="tf-toggle-label">1D</span></label>
</div>

<!-- AUTO-SCAN INTERVAL -->
<div class="form-group">
<label class="form-label">üîÑ Auto-Scan Interval</label>
<select class="form-select" id="scanInterval">
<option value="60000">1 Minute</option>
<option value="180000">3 Minutes</option>
<option value="300000" selected>5 Minutes</option>
<option value="600000">10 Minutes</option>
</select>
</div>

<!-- ALERTS SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">üîî Alert Settings</div>
<div class="form-group">
<label class="alert-toggle"><input type="checkbox" id="alertSound" checked><span class="alert-toggle-label">üîä Sound Alert on New Signal</span></label>
</div>
<div class="form-group">
<label class="alert-toggle"><input type="checkbox" id="alertVibrate"><span class="alert-toggle-label">üì≥ Vibrate on New Signal</span></label>
</div>
<div class="form-group">
<label class="form-label">Alert for Grade</label>
<select class="form-select" id="alertGrade">
<option value="PERFECT">PERFECT only</option>
<option value="STRONG" selected>STRONG and above</option>
<option value="VALID">VALID and above</option>
<option value="ALL">All signals</option>
</select>
</div>
<button class="btn" onclick="testAlert()" style="width:100%;margin-top:8px">üîî Test Alert</button>

<!-- TELEGRAM SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">üì± Telegram Alerts</div>
<div class="form-group">
<label class="alert-toggle"><input type="checkbox" id="telegramEnabled"><span class="alert-toggle-label">Enable Telegram Alerts</span></label>
</div>
<div class="form-group">
<label class="form-label">Bot Token</label>
<input type="text" class="form-input" id="telegramToken" placeholder="123456789:ABCdefGHI...">
</div>
<div class="form-group">
<label class="form-label">Chat ID</label>
<input type="text" class="form-input" id="telegramChatId" placeholder="Your chat ID">
</div>
<button class="btn" onclick="testTelegram()" style="width:100%;margin-top:8px">üì± Test Telegram</button>

<!-- THEME SECTION -->
<div style="font-size:13px;font-weight:700;color:var(--cyan);margin:16px 0 10px 0;border-bottom:1px solid var(--border);padding-bottom:6px">üé® Theme</div>
<div class="form-group">
<label class="alert-toggle"><input type="checkbox" id="oledTheme"><span class="alert-toggle-label">üåô OLED Black Theme (Battery Saver)</span></label>
</div>

</div>
<div class="modal-foot">
<button class="btn" onclick="hideSettings()">Cancel</button>
<button class="btn active" onclick="saveSettings()">Save</button>
</div>
</div>
</div>
<div class="toast-box" id="toastBox"></div>

<script>
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// Bybit Scanner - CONFIGURATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

const CONFIG = {
    // FULL 200 COINS LIST - Bybit perpetuals
    ALL_COINS: [
        // Top 50 (Default)
        'BTCUSDT','ETHUSDT','SOLUSDT','XRPUSDT','DOGEUSDT','ADAUSDT','AVAXUSDT','LINKUSDT',
        'DOTUSDT','MATICUSDT','UNIUSDT','LTCUSDT','ATOMUSDT','ETCUSDT','XLMUSDT','APTUSDT',
        'NEARUSDT','OPUSDT','ARBUSDT','INJUSDT','FILUSDT','LDOUSDT','SUIUSDT','SEIUSDT',
        'TIAUSDT','JUPUSDT','STXUSDT','IMXUSDT','RUNEUSDT','FETUSDT','AGIXUSDT','RNDRUSDT',
        'WLDUSDT','PENDLEUSDT','ENAUSDT','WUSDT','TAOUSDT','KASUSDT','PEPEUSDT','BONKUSDT',
        'FLOKIUSDT','SHIBUSDT','ORDIUSDT','1000SATSUSDT','WIFUSDT','BOMEUSDT','MEWUSDT',
        'POPCATUSDT','NOTUSDT','TONUSDT',
        // 51-100
        'AAVEUSDT','MKRUSDT','SNXUSDT','COMPUSDT','CRVUSDT','YFIUSDT','SUSHIUSDT','1INCHUSDT',
        'DYDXUSDT','GMXUSDT','PERPUSDT','UMAUSDT','ZRXUSDT','LRCUSDT','KNCUSDT','BALUSDT',
        'OCEANUSDT','GRTUSDT','ILVUSDT','AXSUSDT','SANDUSDT','MANAUSDT','GALAUSDT','ENJUSDT',
        'CHZUSDT','FLOWUSDT','ROSAUSDT','MINAUSDT','KAVAUSDT','ALGOUSDT','QNTUSDT','VETUSDT',
        'HBARUSDT','EGLDUSDT','FTMUSDT','ONEUSDT','ZILUSDT','ICPUSDT','THETAUSDT','NEOUSDT',
        'IOTAUSDT','XTZUSDT','EOSUSDT','XECUSDT','BCHUSDT','BSVUSDT','DASHUSDT','ZECUSDT',
        'XMRUSDT','DCRUSDT',
        // 101-150
        'KSMUSDT','ARUSDT','STORJUSDT','ANKRUSDT','SKLUSDT','CELOUSDT','CTSIUSDT','BANDUSDT',
        'RLCUSDT','NMRUSDT','OXTUSDT','STMXUSDT','DENTUSDT','HOTUSDT','SCUSDT','CKBUSDT',
        'RVNUSDT','DGBUSDT','BTGUSDT','ONTUSDT','IOSTUSDT','ZENUSDT','WAVESUSDT','RENUSDT',
        'LPTUSDT','API3USDT','MASKUSDT','HIGHUSDT','BICOUSDT','BLURUSDT','ARPAUSDT',
        'MAGICUSDT','GMTUSDT','APEUSDT','LOOKSUSDT','AUDIOUSDT','RDNTUSDT','CFXUSDT',
        'LEVERUSDT','MDTUSDT','AMBUSDT','PHBUSDT','TUSDT','POLYXUSDT','VIBUSDT','PROSUSDT',
        'SYNUSDT','HOOKUSDT','IDUSDT','EDUUSDT','MAVUSDT','CYBERUSDT',
        // 151-200
        'ARKMUSDT','FRONTUSDT','GLMRUSDT','AGLDUSDT','YGGUSDT','TRUUSDT','LQTYUSDT','TUSDT',
        'XVSUSDT','ALPACAUSDT','TLMUSDT','DARUSDT','MOVRUSDT','RADUSDT','MBOXUSDT','RAREUSDT',
        'SUPERUSDT','PORTALUSDT','PIXELUSDT','STRKUSDT','ACEUSDT','XAIUSDT','ALTUSDT','JTOUSDT',
        'MANTAUSDT','RONINUSDT','DYMUSDT','OMUSDT','PYTHUSDT','ZETAUSDT','LSKUSDT','SAGAUSDT',
        'TNSRUSDT','AEVOUSDT','REZUSDT','BBUSDT','IOUSDT','ZKUSDT','LISTAUSDT','WUSDT',
        'RENDERUSDT','ATHUSDT','EIGENUSDT','SCRUSDT','MORPHOUSDT','DRIFTUSDT','SAFEUSDT',
        'GRASSUSDT','MOVEUSDT','MEUSDT','VANAUSDT','TRUMPUSDT'
    ],
    
    // Active coins list (can be modified by user)
    COINS: [],
    
    // Timeframes for scanning
    TF_SCALP: ['5','15','30','60'],      // 5m, 15m, 30m, 1H
    TF_SWING: ['60','240','D'],           // 1H, 4H, 1D
    TF_ALL: ['5','15','30','60','240','D'],
    TF_LABELS: {'5':'5m','15':'15m','30':'30m','60':'1H','240':'4H','D':'1D','W':'1W'},
    
    // HTF mapping for each entry TF
    HTF_MAP: {
        '5': ['15','60','240'],    // 5m entry ‚Üí check 15m, 1H, 4H
        '15': ['60','240','D'],    // 15m entry ‚Üí check 1H, 4H, 1D
        '30': ['60','240','D'],    // 30m entry ‚Üí check 1H, 4H, 1D
        '60': ['240','D','W'],     // 1H entry ‚Üí check 4H, 1D, 1W
        '240': ['D','W'],          // 4H entry ‚Üí check 1D, 1W
        'D': ['W']                 // 1D entry ‚Üí check 1W
    },
    
    // Zone Analysis TFs for multi-TF confluence
    ZONE_TFS: ['15','30','60','240','D','W'],
    
    // Scoring weights (can be modified by user)
    WEIGHTS: { zone: 0.35, smc: 0.35, momentum: 0.30 },
    
    // Grade thresholds
    GRADES: {
        PERFECT: 85,
        STRONG: 70,
        VALID: 55,
        HEATING: 40
    },
    
    // Conflict penalties
    PENALTIES: {
        ZONE_SMC_CONFLICT: -20,
        HTF_CONFLICT: -10,
        EXHAUSTION: -10,
        DIVERGENCE_AGAINST: -15
    },
    
    // API
    BYBIT_BASE: 'https://api.bybit.com',
    GROQ_URL: 'https://api.groq.com/openai/v1/chat/completions',
    DEEPSEEK_URL: 'https://api.deepseek.com/v1/chat/completions',
    GEMINI_URL: 'https://generativelanguage.googleapis.com/v1beta/models/gemini-1.5-flash:generateContent',
    
    // Scan intervals
    SCAN_DELAY: 100,        // ms between API calls
    AUTO_SCAN_INTERVAL: 60000  // 1 minute
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// STATE MANAGEMENT
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MULTI-AI PROVIDER SYSTEM (v13 UPGRADE)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Groq API Keys (5 keys for rotation) - Add your keys in Settings
const GROQ_KEYS = [
    '', // Add your Groq key in Settings
    '',
    '',
    '',
    ''
];

// DeepSeek API Keys (paid - best value)
const DEEPSEEK_KEYS = [
    '', // Add your DeepSeek key in Settings
];

// Gemini API Keys (free backup)
const GEMINI_KEYS = [
    '', // Add your Gemini key in Settings
    '',
    '',
    '',
    ''
];

let currentGroqKeyIndex = 0;
let currentDeepSeekKeyIndex = 0;
let currentGeminiKeyIndex = 0;

// Get next API key with rotation
function getNextGroqKey() {
    const validKeys = GROQ_KEYS.filter(k => k && k.trim() !== '');
    if (validKeys.length === 0) return null;
    const key = validKeys[currentGroqKeyIndex % validKeys.length];
    console.log(`üîë Using Groq Key #${(currentGroqKeyIndex % validKeys.length) + 1} of ${validKeys.length}`);
    currentGroqKeyIndex++;
    return key;
}

function getNextDeepSeekKey() {
    const validKeys = DEEPSEEK_KEYS.filter(k => k && k.trim() !== '');
    if (validKeys.length === 0) return null;
    const key = validKeys[currentDeepSeekKeyIndex % validKeys.length];
    console.log(`üîë Using DeepSeek Key #${(currentDeepSeekKeyIndex % validKeys.length) + 1} of ${validKeys.length}`);
    currentDeepSeekKeyIndex++;
    return key;
}

function getNextGeminiKey() {
    const validKeys = GEMINI_KEYS.filter(k => k && k.trim() !== '');
    if (validKeys.length === 0) return null;
    const key = validKeys[currentGeminiKeyIndex % validKeys.length];
    console.log(`üîë Using Gemini Key #${(currentGeminiKeyIndex % validKeys.length) + 1} of ${validKeys.length}`);
    currentGeminiKeyIndex++;
    return key;
}

// Legacy support
const API_KEYS = GROQ_KEYS;
let currentKeyIndex = 0;

// Get next API key (round-robin rotation) - Legacy support
function getNextAPIKey() {
    return getNextGroqKey() || API_KEYS[0];
}

const DEFAULT_KEY = '';

const STATE = {
    mode: 'ALL',
    filter: 'all',
    statsFilter: 'all',  // Stats bar filter: 'all', 'perfect', 'long', 'short', 'agree3'
    view: 'list',  // 'list' or 'heatmap'
    scanning: false,
    signals: [],
    previousSignals: [],  // For tracking changes (‚¨ÜÔ∏è‚¨áÔ∏èüÜïüíÄ)
    selected: null,
    current: null,
    aiResult: null,
    trades: [],
    signalHistory: [],  // Track TP/SL hits
    btc: { price: 0, change: 0 },
    // Market data for badges
    fearGreed: null,
    dxy: null,
    funding: null,
    btcDominance: null,
    btcDomTrend: 'flat',
    altSeasonScore: 50,
    aiKey: DEFAULT_KEY,
    aiModel: 'llama-3.3-70b-versatile',
    // v13 Multi-AI Keys
    deepseekKey: '',
    geminiKey: '',
    scanProgress: { current: 0, total: 0, coin: '', tf: '' },
    // Timeframe toggles
    tfEnabled: {
        '5': true,
        '15': true,
        '30': true,
        '60': true,
        '240': true,
        'D': true
    },
    // Alert settings
    alertSound: true,
    alertVibrate: false,
    alertGrade: 'STRONG',
    // Telegram settings
    telegramEnabled: false,
    telegramToken: '',
    telegramChatId: '',
    // Scan interval (ms)
    scanInterval: 300000,  // 5 minutes default
    // AI expanded state
    aiExpanded: false,
    // Risk management
    riskAccount: 1000,
    riskPercent: 2,
    riskLeverage: 10,
    riskMaxPosition: 500,
    // Theme
    oledTheme: false,
    // Custom coins (if modified)
    customCoins: null,
    coinCount: 50
};

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// UTILITY FUNCTIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function toast(msg, type = '') {
    const box = document.getElementById('toastBox');
    const t = document.createElement('div');
    t.className = 'toast ' + type;
    t.textContent = msg;
    box.appendChild(t);
    setTimeout(() => t.remove(), 3500);
}

function fmtPrice(p) {
    if (!p || isNaN(p)) return '0';
    if (p >= 1000) return p.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
    if (p >= 1) return p.toFixed(4);
    if (p >= 0.001) return p.toFixed(6);
    return p.toFixed(8);
}

function fmtPct(p) {
    return (p >= 0 ? '+' : '') + p.toFixed(2) + '%';
}

function sleep(ms) {
    return new Promise(r => setTimeout(r, ms));
}

function scoreColor(s) {
    if (s >= 70) return 'var(--long)';
    if (s >= 50) return 'var(--amber)';
    return 'var(--short)';
}

function scoreClass(s) {
    if (s >= 70) return 'good';
    if (s >= 50) return 'mid';
    return 'low';
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// API FUNCTIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async function fetchJSON(url) {
    try {
        const r = await fetch(url);
        if (r.ok) return await r.json();
    } catch (e) {}
    // Fallback to proxy
    try {
        const r2 = await fetch('https://api.allorigins.win/raw?url=' + encodeURIComponent(url));
        if (r2.ok) return await r2.json();
    } catch (e2) {}
    return null;
}

async function fetchKlines(symbol, tf, limit = 200) {
    const url = `${CONFIG.BYBIT_BASE}/v5/market/kline?category=linear&symbol=${symbol}&interval=${tf}&limit=${limit}`;
    const d = await fetchJSON(url);
    if (d && d.result && d.result.list) {
        return d.result.list.reverse().map(k => ({
            time: parseInt(k[0]),
            open: parseFloat(k[1]),
            high: parseFloat(k[2]),
            low: parseFloat(k[3]),
            close: parseFloat(k[4]),
            volume: parseFloat(k[5])
        }));
    }
    return null;
}

async function fetchBTC() {
    const d = await fetchJSON(`${CONFIG.BYBIT_BASE}/v5/market/tickers?category=linear&symbol=BTCUSDT`);
    if (d && d.result && d.result.list && d.result.list[0]) {
        STATE.btc.price = parseFloat(d.result.list[0].lastPrice);
        STATE.btc.change = parseFloat(d.result.list[0].price24hPcnt) * 100;
        // Update BTC badge
        const btcBadge = document.getElementById('badgeBTC');
        const btcVal = document.getElementById('badgeBTCVal');
        if (btcVal) {
            const priceK = (STATE.btc.price / 1000).toFixed(1) + 'K';
            const arrow = STATE.btc.change >= 0 ? '‚ñ≤' : '‚ñº';
            btcVal.textContent = priceK + arrow;
            btcBadge.className = 'm-badge ' + (STATE.btc.change >= 0 ? 'bull' : 'bear');
        }
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MARKET BADGES DATA FETCHING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Fetch Fear & Greed Index
async function fetchFearGreed() {
    try {
        const d = await fetchJSON('https://api.alternative.me/fng/?limit=1');
        if (d && d.data && d.data[0]) {
            const value = parseInt(d.data[0].value);
            STATE.fearGreed = value;
            const badge = document.getElementById('badgeFG');
            const val = document.getElementById('badgeFGVal');
            if (val) {
                val.textContent = value;
                // Green for fear (<=40), Red for greed (>=60), neutral otherwise
                if (value <= 40) {
                    badge.className = 'm-badge bull';
                } else if (value >= 60) {
                    badge.className = 'm-badge bear';
                } else {
                    badge.className = 'm-badge neutral';
                }
            }
        }
    } catch(e) { console.log('Fear & Greed fetch error:', e); }
}

// Fetch DXY Index
async function fetchDXY() {
    try {
        // Using Yahoo Finance via AllOrigins proxy
        const url = 'https://query1.finance.yahoo.com/v8/finance/chart/DX-Y.NYB?interval=1d&range=1d';
        const proxyUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`;
        const d = await fetchJSON(proxyUrl);
        if (d && d.chart && d.chart.result && d.chart.result[0]) {
            const meta = d.chart.result[0].meta;
            const price = meta.regularMarketPrice || meta.previousClose;
            const prevPrice = meta.chartPreviousClose || meta.previousClose;
            STATE.dxy = { price, prevPrice };
            const badge = document.getElementById('badgeDXY');
            const val = document.getElementById('badgeDXYVal');
            if (val && price) {
                const trend = price > prevPrice ? '‚ñ≤' : price < prevPrice ? '‚ñº' : '';
                val.textContent = price.toFixed(1) + trend;
                // Arrow direction based: UP = green, DOWN = red
                if (trend === '‚ñ≤') {
                    badge.className = 'm-badge bull';
                } else if (trend === '‚ñº') {
                    badge.className = 'm-badge bear';
                } else {
                    badge.className = 'm-badge neutral';
                }
            }
        }
    } catch(e) { 
        console.log('DXY fetch error:', e);
        // Fallback: show placeholder
        const val = document.getElementById('badgeDXYVal');
        if (val) val.textContent = '---';
    }
}

// Fetch Funding Rate
async function fetchFunding() {
    try {
        const d = await fetchJSON(`${CONFIG.BYBIT_BASE}/v5/market/tickers?category=linear&symbol=BTCUSDT`);
        if (d && d.result && d.result.list && d.result.list[0]) {
            const rate = parseFloat(d.result.list[0].fundingRate) * 100;
            STATE.funding = rate;
            const badge = document.getElementById('badgeFund');
            const val = document.getElementById('badgeFundVal');
            if (val) {
                val.textContent = (rate >= 0 ? '+' : '') + rate.toFixed(3) + '%';
                // Negative funding = green (longs favored), Positive = red (shorts favored)
                if (rate < 0) {
                    badge.className = 'm-badge bull';
                } else if (rate > 0.01) {
                    badge.className = 'm-badge bear';
                } else {
                    badge.className = 'm-badge neutral';
                }
            }
        }
    } catch(e) { console.log('Funding fetch error:', e); }
}

// Fetch BTC Dominance
async function fetchBTCDominance() {
    try {
        const d = await fetchJSON('https://api.coingecko.com/api/v3/global');
        if (d && d.data && d.data.market_cap_percentage) {
            const dom = d.data.market_cap_percentage.btc;
            const prevDom = STATE.btcDominance || dom;
            STATE.btcDominance = dom;
            STATE.btcDomTrend = dom > prevDom ? 'rising' : dom < prevDom ? 'falling' : 'flat';
            
            const badge = document.getElementById('badgeDom');
            const val = document.getElementById('badgeDomVal');
            if (val) {
                const arrow = STATE.btcDomTrend === 'rising' ? '‚ñ≤' : STATE.btcDomTrend === 'falling' ? '‚ñº' : '';
                val.textContent = dom.toFixed(1) + '%' + arrow;
                
                // Apply flash based on dominance level and trend
                badge.className = 'm-badge ' + getDomFlashClass(dom, STATE.btcDomTrend);
            }
            
            // Update Season badge based on dominance
            updateSeasonBadge(dom, STATE.btcDomTrend);
        }
    } catch(e) { console.log('BTC Dominance fetch error:', e); }
}

// Get dominance flash class
function getDomFlashClass(dom, trend) {
    if (dom < 50 && trend === 'falling') return 'flash-bright-green';
    if (dom >= 50 && dom < 55 && trend === 'falling') return 'flash-dim-green';
    if (dom > 65 && trend === 'rising') return 'flash-bright-red';
    if (dom > 60 && dom <= 65 && trend === 'rising') return 'flash-dim-red';
    return 'neutral';
}

// Update Alt/BTC Season badge
function updateSeasonBadge(dom, trend) {
    const badge = document.getElementById('badgeSeason');
    const icon = document.getElementById('badgeSeasonIcon');
    const label = document.getElementById('badgeSeasonLabel');
    const val = document.getElementById('badgeSeasonVal');
    if (!badge || !val || !icon || !label) return;
    
    // Calculate alt season score (0-100, higher = more alt season)
    let altScore = 100 - dom; // Base: inverse of dominance
    if (trend === 'falling') altScore += 10;
    if (trend === 'rising') altScore -= 10;
    altScore = Math.max(0, Math.min(100, altScore));
    
    STATE.altSeasonScore = altScore;
    
    if (altScore >= 60) {
        // Alt Season
        icon.textContent = 'üåô';
        val.textContent = Math.round(altScore);
        if (altScore >= 80) {
            badge.className = 'm-badge flash-bright-green';
        } else {
            badge.className = 'm-badge flash-dim-green';
        }
    } else if (altScore <= 40) {
        // BTC Season
        const btcScore = 100 - altScore;
        icon.textContent = '‚Çø';
        val.textContent = Math.round(btcScore);
        if (altScore <= 20) {
            badge.className = 'm-badge flash-bright-red';
        } else {
            badge.className = 'm-badge flash-dim-red';
        }
    } else {
        // Neutral
        icon.textContent = '‚öñÔ∏è';
        val.textContent = Math.round(altScore);
        badge.className = 'm-badge neutral';
    }
}

// Update Trading Session Badge
function updateSessionBadge() {
    const badge = document.getElementById('badgeSession');
    const icon = badge?.querySelector('.m-badge-icon');
    const val = document.getElementById('badgeSessionVal');
    if (!badge || !val) return;
    
    const now = new Date();
    const utcHour = now.getUTCHours();
    
    let session = '---';
    let sessionIcon = 'üåë';
    let isActive = false;
    
    // Session times (UTC)
    if (utcHour >= 0 && utcHour < 8) {
        session = 'ASIA';
        sessionIcon = 'üåè';
        isActive = true;
    } else if (utcHour >= 8 && utcHour < 12) {
        session = 'LDN';
        sessionIcon = 'üåç';
        isActive = true;
    } else if (utcHour >= 12 && utcHour < 17) {
        session = 'NY';
        sessionIcon = 'üåé';
        isActive = true;
    } else if (utcHour >= 17 && utcHour < 21) {
        session = 'NY';
        sessionIcon = 'üåé';
        isActive = true;
    } else {
        session = '---';
        sessionIcon = 'üåë';
        isActive = false;
    }
    
    if (icon) icon.textContent = sessionIcon;
    val.textContent = session;
    badge.className = isActive ? 'm-badge bull' : 'm-badge neutral';
}

// Fetch all market data
async function fetchAllMarketData() {
    await Promise.all([
        fetchFearGreed(),
        fetchDXY(),
        fetchFunding(),
        fetchBTCDominance()
    ]);
    updateSessionBadge();
}

// Update scan progress bar when complete
function setScanComplete() {
    const fill = document.getElementById('scanProgressFill');
    const text = document.getElementById('scanProgressText');
    const pct = document.getElementById('scanProgressPct');
    
    if (fill) {
        fill.style.width = '100%';
        fill.classList.remove('scanning');
        fill.classList.add('done');
    }
    if (text) {
        text.textContent = '‚úÖ Complete';
        text.classList.add('done');
    }
    if (pct) {
        pct.textContent = '100%';
        pct.classList.add('done');
    }
}

// Reset scan progress bar
function resetScanProgress() {
    const bar = document.getElementById('scanProgressBar');
    const fill = document.getElementById('scanProgressFill');
    const text = document.getElementById('scanProgressText');
    const pct = document.getElementById('scanProgressPct');
    
    if (bar) {
        bar.classList.add('active');
    }
    if (fill) {
        fill.style.width = '5%'; // Start with visible bar
        fill.classList.remove('done', 'error');
        fill.classList.add('scanning');
    }
    if (text) {
        text.textContent = 'üîÑ Starting...';
        text.classList.remove('done', 'error');
    }
    if (pct) {
        pct.textContent = '0%';
        pct.classList.remove('done', 'error');
    }
}

// Set scan error state (red)
function setScanError(message) {
    const fill = document.getElementById('scanProgressFill');
    const text = document.getElementById('scanProgressText');
    const pct = document.getElementById('scanProgressPct');
    
    if (fill) {
        fill.classList.remove('scanning', 'done');
        fill.classList.add('error');
    }
    if (text) {
        text.textContent = '‚ùå ' + (message || 'Error');
        text.classList.add('error');
    }
    if (pct) {
        pct.classList.add('error');
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// STATS BAR FILTER FUNCTION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function filterByStats(type) {
    STATE.statsFilter = type;
    updateSignalList();
    
    // Highlight active stat box
    document.querySelectorAll('.stat-box').forEach(box => {
        box.style.borderColor = 'var(--border)';
    });
    
    const activeBox = event.currentTarget;
    if (type !== 'all') {
        activeBox.style.borderColor = 'var(--gold)';
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SMART LIMIT ORDER ENGINE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function calculateSmartLimitEntry(currentPrice, direction, atr, zoneDetails, smcDetails, adx) {
    const result = {
        limitEntry: null,
        entryType: null,  // 'ZONE' or 'ATR'
        zoneScore: 0,
        atrScore: 0,
        confidence: 0
    };
    
    // Get relevant zone
    const zone = direction === 'LONG' ? zoneDetails.nearestSupport : zoneDetails.nearestResistance;
    
    // Calculate Zone Score (if zone exists)
    if (zone) {
        let zScore = 0;
        
        // Touch count (max 25)
        if (zone.touches >= 4) zScore += 25;
        else if (zone.touches >= 3) zScore += 20;
        else if (zone.touches >= 2) zScore += 15;
        else zScore += 5;
        
        // Distance to zone (max 25)
        const zonePrice = direction === 'LONG' ? zone.high : zone.low;
        const distancePct = Math.abs(currentPrice - zonePrice) / currentPrice * 100;
        if (distancePct <= 0.5) zScore += 25;
        else if (distancePct <= 1.0) zScore += 22;
        else if (distancePct <= 1.5) zScore += 18;
        else if (distancePct <= 2.0) zScore += 12;
        else if (distancePct <= 3.0) zScore += 5;
        
        // Order Block confluence (max 20)
        if (smcDetails && smcDetails.orderBlocks) {
            const obs = direction === 'LONG' ? smcDetails.orderBlocks.bullish : smcDetails.orderBlocks.bearish;
            const obAtZone = obs && obs.some(ob => Math.abs(ob.price - zonePrice) / zonePrice < 0.01);
            if (obAtZone) zScore += 20;
        }
        
        // Zone strength (max 15)
        if (zone.strength >= 70) zScore += 15;
        else if (zone.strength >= 50) zScore += 10;
        else zScore += 5;
        
        result.zoneScore = Math.min(100, zScore);
        result.zoneEntry = direction === 'LONG' ? zone.high * 1.002 : zone.low * 0.998;
    }
    
    // Calculate ATR Entry
    let pullbackMult = 0.4;
    const adxVal = adx || 25;
    
    // Adjust by trend strength
    if (adxVal > 40) pullbackMult = 0.25;
    else if (adxVal > 30) pullbackMult = 0.35;
    else if (adxVal > 20) pullbackMult = 0.45;
    else pullbackMult = 0.55;
    
    result.atrEntry = direction === 'LONG' 
        ? currentPrice - (atr * pullbackMult)
        : currentPrice + (atr * pullbackMult);
    
    // ATR Score
    result.atrScore = 50;
    if (adxVal > 30) result.atrScore += 20;
    else if (adxVal > 25) result.atrScore += 10;
    if (!zone || result.zoneScore < 40) result.atrScore += 15;
    result.atrScore = Math.min(100, result.atrScore);
    
    // Decision: Zone vs ATR
    if (result.zoneScore >= 70 && zone) {
        const distPct = Math.abs(currentPrice - result.zoneEntry) / currentPrice * 100;
        if (distPct <= 2.0) {
            result.entryType = 'ZONE';
            result.limitEntry = result.zoneEntry;
            result.confidence = Math.round(result.zoneScore * 0.9);
        }
    }
    
    if (!result.entryType) {
        if (result.zoneScore > result.atrScore && result.zoneScore >= 50) {
            result.entryType = 'ZONE';
            result.limitEntry = result.zoneEntry;
            result.confidence = Math.round(result.zoneScore * 0.85);
        } else {
            result.entryType = 'ATR';
            result.limitEntry = result.atrEntry;
            result.confidence = Math.round(result.atrScore * 0.85);
        }
    }
    
    // Safety: max 3% from current price
    const maxDist = 0.03;
    const entryDist = Math.abs(currentPrice - result.limitEntry) / currentPrice;
    if (entryDist > maxDist) {
        result.limitEntry = direction === 'LONG'
            ? currentPrice * (1 - maxDist)
            : currentPrice * (1 + maxDist);
        result.confidence = Math.round(result.confidence * 0.8);
    }
    
    return result;
}


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ZONE ANALYSIS ENGINE - COMPLETE IMPLEMENTATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Find swing highs and lows with configurable left/right bars
function findSwingPoints(klines, leftBars = 5, rightBars = 5) {
    const swingHighs = [];
    const swingLows = [];
    
    if (!klines || klines.length < leftBars + rightBars + 1) return { highs: [], lows: [] };
    
    for (let i = leftBars; i < klines.length - rightBars; i++) {
        let isHigh = true;
        let isLow = true;
        
        const currentHigh = klines[i].high;
        const currentLow = klines[i].low;
        
        // Check left bars
        for (let j = i - leftBars; j < i; j++) {
            if (klines[j].high >= currentHigh) isHigh = false;
            if (klines[j].low <= currentLow) isLow = false;
        }
        
        // Check right bars
        for (let j = i + 1; j <= i + rightBars; j++) {
            if (klines[j].high >= currentHigh) isHigh = false;
            if (klines[j].low <= currentLow) isLow = false;
        }
        
        if (isHigh) {
            swingHighs.push({
                index: i,
                price: currentHigh,
                time: klines[i].time,
                volume: klines[i].volume
            });
        }
        
        if (isLow) {
            swingLows.push({
                index: i,
                price: currentLow,
                time: klines[i].time,
                volume: klines[i].volume
            });
        }
    }
    
    return { highs: swingHighs, lows: swingLows };
}

// Cluster nearby price levels into zones
function clusterZones(points, threshold = 0.005) {
    if (!points || points.length === 0) return [];
    
    const sorted = [...points].sort((a, b) => a.price - b.price);
    const clusters = [];
    let currentCluster = [sorted[0]];
    
    for (let i = 1; i < sorted.length; i++) {
        const clusterAvg = currentCluster.reduce((sum, p) => sum + p.price, 0) / currentCluster.length;
        const pctDiff = Math.abs(sorted[i].price - clusterAvg) / clusterAvg;
        
        if (pctDiff <= threshold) {
            currentCluster.push(sorted[i]);
        } else {
            clusters.push(currentCluster);
            currentCluster = [sorted[i]];
        }
    }
    clusters.push(currentCluster);
    
    // Convert clusters to zones
    return clusters.map(cluster => {
        const prices = cluster.map(p => p.price);
        const high = Math.max(...prices);
        const low = Math.min(...prices);
        const totalVolume = cluster.reduce((sum, p) => sum + (p.volume || 0), 0);
        const times = cluster.map(p => p.time);
        
        return {
            high: high,
            low: low,
            price: (high + low) / 2,
            touches: cluster.length,
            volume: totalVolume,
            firstTouch: Math.min(...times),
            lastTouch: Math.max(...times),
            indices: cluster.map(p => p.index)
        };
    });
}

// Calculate zone strength with decay over time
function calcZoneStrength(zone, currentIndex, totalBars, avgVolume) {
    let strength = 0;
    
    // Touch count bonus (max 30 points)
    if (zone.touches >= 5) strength += 30;
    else if (zone.touches >= 4) strength += 25;
    else if (zone.touches >= 3) strength += 20;
    else if (zone.touches >= 2) strength += 12;
    else strength += 5;
    
    // Volume bonus (max 20 points)
    if (avgVolume > 0) {
        const volRatio = zone.volume / (avgVolume * zone.touches);
        if (volRatio >= 2.0) strength += 20;
        else if (volRatio >= 1.5) strength += 15;
        else if (volRatio >= 1.2) strength += 10;
        else if (volRatio >= 1.0) strength += 5;
    }
    
    // Freshness bonus (max 20 points) - newer zones are stronger
    const lastTouchIndex = Math.max(...zone.indices);
    const barsSinceTouch = currentIndex - lastTouchIndex;
    if (barsSinceTouch <= 10) strength += 20;
    else if (barsSinceTouch <= 25) strength += 15;
    else if (barsSinceTouch <= 50) strength += 10;
    else if (barsSinceTouch <= 100) strength += 5;
    // else: old zone, no freshness bonus
    
    // Age decay - reduce strength for very old zones
    const firstTouchIndex = Math.min(...zone.indices);
    const zoneAge = currentIndex - firstTouchIndex;
    if (zoneAge > 150) strength -= 10;
    else if (zoneAge > 100) strength -= 5;
    
    return Math.max(0, Math.min(100, strength));
}

// Check if price is at a round number
function checkRoundNumber(price) {
    let bonus = 0;
    const priceStr = price.toString();
    
    // Check for major round numbers
    if (price >= 1000) {
        if (price % 10000 === 0) bonus = 8;      // 10000, 20000, etc.
        else if (price % 5000 === 0) bonus = 6;  // 5000, 15000, etc.
        else if (price % 1000 === 0) bonus = 4;  // 1000, 2000, etc.
        else if (price % 500 === 0) bonus = 3;
        else if (price % 100 === 0) bonus = 2;
    } else if (price >= 1) {
        if (price % 100 === 0) bonus = 5;
        else if (price % 50 === 0) bonus = 4;
        else if (price % 10 === 0) bonus = 3;
        else if (price % 5 === 0) bonus = 2;
        else if (price % 1 === 0) bonus = 1;
    } else {
        // For small prices like 0.00001234
        const decimals = priceStr.split('.')[1] || '';
        const zeros = (decimals.match(/0+$/) || [''])[0].length;
        if (zeros >= 4) bonus = 4;
        else if (zeros >= 3) bonus = 3;
        else if (zeros >= 2) bonus = 2;
    }
    
    return bonus;
}

// Calculate Fibonacci levels from swing high to swing low
function calcFibLevels(swingHigh, swingLow) {
    const range = swingHigh - swingLow;
    return {
        level_0: swingLow,
        level_236: swingLow + range * 0.236,
        level_382: swingLow + range * 0.382,
        level_5: swingLow + range * 0.5,
        level_618: swingLow + range * 0.618,
        level_786: swingLow + range * 0.786,
        level_1: swingHigh
    };
}

// Check if zone aligns with Fibonacci level
function checkFibAlignment(zonePrice, fibLevels, tolerance = 0.005) {
    const fibs = [0.236, 0.382, 0.5, 0.618, 0.786];
    const fibPrices = [fibLevels.level_236, fibLevels.level_382, fibLevels.level_5, fibLevels.level_618, fibLevels.level_786];
    
    for (let i = 0; i < fibPrices.length; i++) {
        const pctDiff = Math.abs(zonePrice - fibPrices[i]) / fibPrices[i];
        if (pctDiff <= tolerance) {
            return { aligned: true, level: fibs[i], bonus: fibs[i] === 0.618 ? 8 : fibs[i] === 0.5 ? 6 : 4 };
        }
    }
    return { aligned: false, level: null, bonus: 0 };
}

// Detect fakeout (wick through zone but close back inside)
function detectFakeout(klines, zone, lookback = 5) {
    if (!klines || klines.length < lookback) return { detected: false };
    
    const recent = klines.slice(-lookback);
    
    for (const candle of recent) {
        // Bullish fakeout: wick below support but close above
        if (candle.low < zone.low && candle.close > zone.low && candle.close > candle.open) {
            return { detected: true, type: 'bullish', strength: 'strong' };
        }
        // Bearish fakeout: wick above resistance but close below
        if (candle.high > zone.high && candle.close < zone.high && candle.close < candle.open) {
            return { detected: true, type: 'bearish', strength: 'strong' };
        }
    }
    
    return { detected: false };
}

// Get distance status from current price to zone
function getZoneDistance(currentPrice, zone) {
    const zoneMid = zone.price;
    const pctDistance = Math.abs(currentPrice - zoneMid) / currentPrice * 100;
    
    let status, score;
    if (pctDistance <= 0.3) {
        status = 'AT';
        score = 40;
    } else if (pctDistance <= 0.8) {
        status = 'CLOSE';
        score = 30;
    } else if (pctDistance <= 1.5) {
        status = 'NEAR';
        score = 20;
    } else if (pctDistance <= 3.0) {
        status = 'APPROACHING';
        score = 10;
    } else {
        status = 'FAR';
        score = 0;
    }
    
    return { status, score, pctDistance };
}

// Multi-timeframe zone confluence analysis
async function analyzeZoneConfluence(symbol, currentPrice, entryTF) {
    const confluenceTFs = CONFIG.ZONE_TFS;
    const allZones = { support: [], resistance: [] };
    
    for (const tf of confluenceTFs) {
        try {
            const klines = await fetchKlines(symbol, tf, 200);
            if (!klines || klines.length < 50) continue;
            
            const swings = findSwingPoints(klines, 5, 5);
            const supportZones = clusterZones(swings.lows, 0.005);
            const resistanceZones = clusterZones(swings.highs, 0.005);
            
            // Tag zones with their timeframe
            supportZones.forEach(z => {
                z.tf = tf;
                z.type = 'support';
                if (z.price < currentPrice) allZones.support.push(z);
            });
            
            resistanceZones.forEach(z => {
                z.tf = tf;
                z.type = 'resistance';
                if (z.price > currentPrice) allZones.resistance.push(z);
            });
            
            await sleep(50);
        } catch (e) {
            console.error(`Zone confluence error for ${tf}:`, e);
        }
    }
    
    // Find confluent zones (zones that appear in multiple TFs)
    const findConfluent = (zones) => {
        const confluent = [];
        const used = new Set();
        
        for (let i = 0; i < zones.length; i++) {
            if (used.has(i)) continue;
            
            const zone = zones[i];
            const matching = [zone];
            
            for (let j = i + 1; j < zones.length; j++) {
                if (used.has(j)) continue;
                
                const other = zones[j];
                const pctDiff = Math.abs(zone.price - other.price) / zone.price;
                
                if (pctDiff <= 0.015) { // 1.5% tolerance for confluence
                    matching.push(other);
                    used.add(j);
                }
            }
            
            if (matching.length >= 1) {
                const tfs = [...new Set(matching.map(m => m.tf))];
                const avgPrice = matching.reduce((sum, m) => sum + m.price, 0) / matching.length;
                const totalTouches = matching.reduce((sum, m) => sum + m.touches, 0);
                
                confluent.push({
                    price: avgPrice,
                    high: Math.max(...matching.map(m => m.high)),
                    low: Math.min(...matching.map(m => m.low)),
                    tfs: tfs,
                    tfCount: tfs.length,
                    totalTouches: totalTouches,
                    type: zone.type
                });
            }
            used.add(i);
        }
        
        return confluent.sort((a, b) => b.tfCount - a.tfCount);
    };
    
    return {
        support: findConfluent(allZones.support),
        resistance: findConfluent(allZones.resistance)
    };
}

// MAIN ZONE ANALYSIS FUNCTION
async function performZoneAnalysis(klines, symbol, tf, currentPrice) {
    const result = {
        score: 0,
        direction: null,
        status: 'FAR',
        factors: [],
        warnings: [],
        details: {}
    };
    
    if (!klines || klines.length < 50) return result;
    
    const len = klines.length;
    const avgVolume = klines.slice(-50).reduce((sum, k) => sum + k.volume, 0) / 50;
    
    // Find swing points
    const swings = findSwingPoints(klines, 5, 5);
    
    // Cluster into zones
    const supportZones = clusterZones(swings.lows, 0.005).filter(z => z.price < currentPrice);
    const resistanceZones = clusterZones(swings.highs, 0.005).filter(z => z.price > currentPrice);
    
    // Calculate strength for each zone
    supportZones.forEach(z => {
        z.strength = calcZoneStrength(z, len - 1, len, avgVolume);
    });
    resistanceZones.forEach(z => {
        z.strength = calcZoneStrength(z, len - 1, len, avgVolume);
    });
    
    // Sort by strength
    supportZones.sort((a, b) => b.strength - a.strength);
    resistanceZones.sort((a, b) => b.strength - a.strength);
    
    // Get nearest zones
    const nearestSupport = supportZones.length > 0 ? supportZones[0] : null;
    const nearestResistance = resistanceZones.length > 0 ? resistanceZones[0] : null;
    
    result.details.nearestSupport = nearestSupport;
    result.details.nearestResistance = nearestResistance;
    result.details.supportCount = supportZones.length;
    result.details.resistanceCount = resistanceZones.length;
    
    // Calculate Fib levels
    const recentHigh = Math.max(...klines.slice(-100).map(k => k.high));
    const recentLow = Math.min(...klines.slice(-100).map(k => k.low));
    const fibLevels = calcFibLevels(recentHigh, recentLow);
    result.details.fibLevels = fibLevels;
    
    let score = 0;
    
    // Check support zone
    if (nearestSupport) {
        const dist = getZoneDistance(currentPrice, nearestSupport);
        
        if (dist.status !== 'FAR') {
            result.direction = 'LONG';
            result.status = dist.status;
            score += dist.score;
            result.factors.push(`${dist.status} Support`);
            
            // Touch count bonus
            if (nearestSupport.touches >= 4) {
                score += 15;
                result.factors.push(`${nearestSupport.touches} touches`);
            } else if (nearestSupport.touches >= 3) {
                score += 10;
                result.factors.push(`${nearestSupport.touches} touches`);
            } else if (nearestSupport.touches >= 2) {
                score += 5;
            }
            
            // Strength bonus
            if (nearestSupport.strength >= 60) {
                score += 10;
                result.factors.push('Strong zone');
            } else if (nearestSupport.strength >= 40) {
                score += 5;
            }
            
            // Round number bonus
            const roundBonus = checkRoundNumber(nearestSupport.price);
            if (roundBonus >= 4) {
                score += roundBonus;
                result.factors.push('Round number');
            }
            
            // Fib alignment bonus
            const fibCheck = checkFibAlignment(nearestSupport.price, fibLevels);
            if (fibCheck.aligned) {
                score += fibCheck.bonus;
                result.factors.push(`Fib ${fibCheck.level}`);
            }
            
            // Fakeout bonus
            const fakeout = detectFakeout(klines, nearestSupport);
            if (fakeout.detected && fakeout.type === 'bullish') {
                score += 12;
                result.factors.push('Fakeout sweep ‚úì');
            }
        }
    }
    
    // Check resistance zone
    if (nearestResistance) {
        const dist = getZoneDistance(currentPrice, nearestResistance);
        
        if (dist.status !== 'FAR' && !result.direction) {
            result.direction = 'SHORT';
            result.status = dist.status;
            score += dist.score;
            result.factors.push(`${dist.status} Resistance`);
            
            // Touch count bonus
            if (nearestResistance.touches >= 4) {
                score += 15;
                result.factors.push(`${nearestResistance.touches} touches`);
            } else if (nearestResistance.touches >= 3) {
                score += 10;
                result.factors.push(`${nearestResistance.touches} touches`);
            } else if (nearestResistance.touches >= 2) {
                score += 5;
            }
            
            // Strength bonus
            if (nearestResistance.strength >= 60) {
                score += 10;
                result.factors.push('Strong zone');
            } else if (nearestResistance.strength >= 40) {
                score += 5;
            }
            
            // Round number bonus
            const roundBonus = checkRoundNumber(nearestResistance.price);
            if (roundBonus >= 4) {
                score += roundBonus;
                result.factors.push('Round number');
            }
            
            // Fib alignment bonus
            const fibCheck = checkFibAlignment(nearestResistance.price, fibLevels);
            if (fibCheck.aligned) {
                score += fibCheck.bonus;
                result.factors.push(`Fib ${fibCheck.level}`);
            }
            
            // Fakeout bonus
            const fakeout = detectFakeout(klines, nearestResistance);
            if (fakeout.detected && fakeout.type === 'bearish') {
                score += 12;
                result.factors.push('Fakeout sweep ‚úì');
            }
        }
    }
    
    // If price is between zones (no clear direction)
    if (!result.direction && nearestSupport && nearestResistance) {
        const supDist = (currentPrice - nearestSupport.price) / currentPrice;
        const resDist = (nearestResistance.price - currentPrice) / currentPrice;
        
        if (supDist < resDist) {
            result.direction = 'LONG';
            result.factors.push('Closer to support');
            score += 5;
        } else {
            result.direction = 'SHORT';
            result.factors.push('Closer to resistance');
            score += 5;
        }
        result.status = 'BETWEEN';
        result.warnings.push('Mid-range - wait for zone');
    }
    
    result.score = Math.min(100, Math.max(0, score));
    return result;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// END OF PART 1 - Zone Analysis Complete
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SMC ANALYSIS ENGINE - COMPLETE IMPLEMENTATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Detect market structure (HH, HL, LH, LL)
function detectStructure(klines, lookback = 50) {
    if (!klines || klines.length < lookback) return { trend: 'NEUTRAL', swings: [], counts: {} };
    
    const swings = findSwingPoints(klines, 3, 3);
    const allSwings = [];
    
    // Combine and sort swings by index
    swings.highs.forEach(h => allSwings.push({ ...h, type: 'high' }));
    swings.lows.forEach(l => allSwings.push({ ...l, type: 'low' }));
    allSwings.sort((a, b) => a.index - b.index);
    
    // Label structure points
    let lastHigh = null;
    let lastLow = null;
    const structure = [];
    const counts = { HH: 0, HL: 0, LH: 0, LL: 0 };
    
    for (const swing of allSwings) {
        if (swing.type === 'high') {
            if (lastHigh !== null) {
                if (swing.price > lastHigh.price) {
                    structure.push({ ...swing, label: 'HH' });
                    counts.HH++;
                } else {
                    structure.push({ ...swing, label: 'LH' });
                    counts.LH++;
                }
            } else {
                structure.push({ ...swing, label: 'H' });
            }
            lastHigh = swing;
        } else {
            if (lastLow !== null) {
                if (swing.price > lastLow.price) {
                    structure.push({ ...swing, label: 'HL' });
                    counts.HL++;
                } else {
                    structure.push({ ...swing, label: 'LL' });
                    counts.LL++;
                }
            } else {
                structure.push({ ...swing, label: 'L' });
            }
            lastLow = swing;
        }
    }
    
    // Determine trend from recent structure
    const recentStructure = structure.slice(-6);
    let bullishPoints = 0;
    let bearishPoints = 0;
    
    recentStructure.forEach(s => {
        if (s.label === 'HH' || s.label === 'HL') bullishPoints++;
        if (s.label === 'LH' || s.label === 'LL') bearishPoints++;
    });
    
    let trend = 'NEUTRAL';
    if (bullishPoints >= 3 && bullishPoints > bearishPoints) trend = 'BULLISH';
    else if (bearishPoints >= 3 && bearishPoints > bullishPoints) trend = 'BEARISH';
    
    return { trend, swings: structure, counts, lastHigh, lastLow };
}

// Detect Break of Structure (BOS) - BODY CLOSE confirmation
function detectBOS(klines, structure) {
    if (!klines || klines.length < 10 || !structure.swings || structure.swings.length < 2) {
        return { detected: false };
    }
    
    const len = klines.length;
    const currentCandle = klines[len - 1];
    const prevCandle = klines[len - 2];
    
    // Get recent swing highs and lows
    const recentHighs = structure.swings.filter(s => s.type === 'high').slice(-3);
    const recentLows = structure.swings.filter(s => s.type === 'low').slice(-3);
    
    // Bullish BOS: Current candle BODY CLOSES above recent swing high
    for (const high of recentHighs) {
        if (prevCandle.close <= high.price && currentCandle.close > high.price) {
            // Confirm it's a body close, not just wick
            if (currentCandle.close > currentCandle.open) { // Green candle
                const bodyTop = currentCandle.close;
                if (bodyTop > high.price) {
                    return {
                        detected: true,
                        direction: 'BULLISH',
                        type: 'BOS',
                        level: high.price,
                        strength: currentCandle.close - high.price > (currentCandle.high - currentCandle.low) * 0.3 ? 'STRONG' : 'NORMAL'
                    };
                }
            }
        }
    }
    
    // Bearish BOS: Current candle BODY CLOSES below recent swing low
    for (const low of recentLows) {
        if (prevCandle.close >= low.price && currentCandle.close < low.price) {
            // Confirm it's a body close, not just wick
            if (currentCandle.close < currentCandle.open) { // Red candle
                const bodyBottom = currentCandle.close;
                if (bodyBottom < low.price) {
                    return {
                        detected: true,
                        direction: 'BEARISH',
                        type: 'BOS',
                        level: low.price,
                        strength: low.price - currentCandle.close > (currentCandle.high - currentCandle.low) * 0.3 ? 'STRONG' : 'NORMAL'
                    };
                }
            }
        }
    }
    
    return { detected: false };
}

// Detect Change of Character (CHoCH)
function detectCHoCH(klines, structure) {
    if (!klines || klines.length < 10 || !structure.swings || structure.swings.length < 4) {
        return { detected: false };
    }
    
    const len = klines.length;
    const currentCandle = klines[len - 1];
    const trend = structure.trend;
    
    const recentHighs = structure.swings.filter(s => s.type === 'high').slice(-3);
    const recentLows = structure.swings.filter(s => s.type === 'low').slice(-3);
    
    // Bullish CHoCH: In a downtrend, price breaks above a lower high
    if (trend === 'BEARISH' && recentHighs.length >= 2) {
        const lastLH = recentHighs.find(h => h.label === 'LH');
        if (lastLH && currentCandle.close > lastLH.price) {
            return {
                detected: true,
                direction: 'BULLISH',
                type: 'CHoCH',
                level: lastLH.price,
                previousTrend: 'BEARISH'
            };
        }
    }
    
    // Bearish CHoCH: In an uptrend, price breaks below a higher low
    if (trend === 'BULLISH' && recentLows.length >= 2) {
        const lastHL = recentLows.find(l => l.label === 'HL');
        if (lastHL && currentCandle.close < lastHL.price) {
            return {
                detected: true,
                direction: 'BEARISH',
                type: 'CHoCH',
                level: lastHL.price,
                previousTrend: 'BULLISH'
            };
        }
    }
    
    return { detected: false };
}

// Detect Order Blocks with Mitigation Tracking
function detectOrderBlocks(klines, lookback = 50) {
    if (!klines || klines.length < lookback) return { bullish: [], bearish: [] };
    
    const len = klines.length;
    const bullishOBs = [];
    const bearishOBs = [];
    const currentPrice = klines[len - 1].close;
    
    // Calculate average volume for filtering
    const avgVolume = klines.slice(-50).reduce((sum, k) => sum + k.volume, 0) / 50;
    
    for (let i = len - lookback; i < len - 3; i++) {
        if (i < 1) continue;
        
        const candle = klines[i];
        const nextCandle = klines[i + 1];
        const followCandle = klines[i + 2];
        
        // Bullish Order Block: Down candle followed by strong up move
        if (candle.close < candle.open) { // Red candle
            const moveUp = followCandle.close - candle.low;
            const candleRange = candle.high - candle.low;
            
            // Strong impulse move away
            if (moveUp > candleRange * 2 && candle.volume > avgVolume * 0.8) {
                // Check if OB has been mitigated
                let mitigated = false;
                let mitigationPct = 0;
                
                for (let j = i + 3; j < len; j++) {
                    if (klines[j].low <= candle.high) {
                        mitigated = true;
                        mitigationPct = Math.min(100, ((candle.high - klines[j].low) / candleRange) * 100);
                        break;
                    }
                }
                
                // Only add if not fully mitigated and price is above
                if (mitigationPct < 100 && currentPrice > candle.low) {
                    bullishOBs.push({
                        high: candle.high,
                        low: candle.low,
                        price: (candle.high + candle.low) / 2,
                        index: i,
                        time: candle.time,
                        volume: candle.volume,
                        mitigated: mitigated,
                        mitigationPct: mitigationPct,
                        fresh: !mitigated
                    });
                }
            }
        }
        
        // Bearish Order Block: Up candle followed by strong down move
        if (candle.close > candle.open) { // Green candle
            const moveDown = candle.high - followCandle.close;
            const candleRange = candle.high - candle.low;
            
            // Strong impulse move away
            if (moveDown > candleRange * 2 && candle.volume > avgVolume * 0.8) {
                // Check if OB has been mitigated
                let mitigated = false;
                let mitigationPct = 0;
                
                for (let j = i + 3; j < len; j++) {
                    if (klines[j].high >= candle.low) {
                        mitigated = true;
                        mitigationPct = Math.min(100, ((klines[j].high - candle.low) / candleRange) * 100);
                        break;
                    }
                }
                
                // Only add if not fully mitigated and price is below
                if (mitigationPct < 100 && currentPrice < candle.high) {
                    bearishOBs.push({
                        high: candle.high,
                        low: candle.low,
                        price: (candle.high + candle.low) / 2,
                        index: i,
                        time: candle.time,
                        volume: candle.volume,
                        mitigated: mitigated,
                        mitigationPct: mitigationPct,
                        fresh: !mitigated
                    });
                }
            }
        }
    }
    
    // Sort by freshness and proximity to current price
    bullishOBs.sort((a, b) => {
        if (a.fresh !== b.fresh) return a.fresh ? -1 : 1;
        return Math.abs(currentPrice - a.price) - Math.abs(currentPrice - b.price);
    });
    
    bearishOBs.sort((a, b) => {
        if (a.fresh !== b.fresh) return a.fresh ? -1 : 1;
        return Math.abs(currentPrice - a.price) - Math.abs(currentPrice - b.price);
    });
    
    return { bullish: bullishOBs.slice(0, 5), bearish: bearishOBs.slice(0, 5) };
}

// Detect Breaker Blocks (Mitigated OB that becomes S/R)
function detectBreakerBlocks(klines, orderBlocks) {
    if (!klines || !orderBlocks) return { bullish: [], bearish: [] };
    
    const len = klines.length;
    const currentPrice = klines[len - 1].close;
    const bullishBreakers = [];
    const bearishBreakers = [];
    
    // Bullish Breaker: Former bearish OB that got broken and now acts as support
    for (const ob of orderBlocks.bearish) {
        if (ob.mitigated && ob.mitigationPct >= 80) {
            // Check if price broke through and is now above
            if (currentPrice > ob.high) {
                // This bearish OB is now a bullish breaker (support)
                bullishBreakers.push({
                    high: ob.high,
                    low: ob.low,
                    price: ob.price,
                    type: 'BREAKER',
                    originalType: 'BEARISH_OB',
                    index: ob.index
                });
            }
        }
    }
    
    // Bearish Breaker: Former bullish OB that got broken and now acts as resistance
    for (const ob of orderBlocks.bullish) {
        if (ob.mitigated && ob.mitigationPct >= 80) {
            // Check if price broke through and is now below
            if (currentPrice < ob.low) {
                // This bullish OB is now a bearish breaker (resistance)
                bearishBreakers.push({
                    high: ob.high,
                    low: ob.low,
                    price: ob.price,
                    type: 'BREAKER',
                    originalType: 'BULLISH_OB',
                    index: ob.index
                });
            }
        }
    }
    
    return { bullish: bullishBreakers, bearish: bearishBreakers };
}

// Detect Fair Value Gaps (FVG) with Fill Tracking
function detectFVG(klines, lookback = 30) {
    if (!klines || klines.length < lookback) return { bullish: [], bearish: [] };
    
    const len = klines.length;
    const bullishFVGs = [];
    const bearishFVGs = [];
    const currentPrice = klines[len - 1].close;
    
    for (let i = len - lookback; i < len - 2; i++) {
        if (i < 1) continue;
        
        const candle1 = klines[i];
        const candle2 = klines[i + 1];
        const candle3 = klines[i + 2];
        
        // Bullish FVG: Gap between candle1 high and candle3 low
        if (candle3.low > candle1.high) {
            const gapHigh = candle3.low;
            const gapLow = candle1.high;
            const gapSize = gapHigh - gapLow;
            const gapPct = (gapSize / candle2.close) * 100;
            
            if (gapPct >= 0.1) { // Minimum gap size
                // Check if FVG has been filled
                let filled = false;
                let fillPct = 0;
                
                for (let j = i + 3; j < len; j++) {
                    if (klines[j].low <= gapHigh) {
                        const fillAmount = gapHigh - Math.max(klines[j].low, gapLow);
                        fillPct = Math.min(100, (fillAmount / gapSize) * 100);
                        if (fillPct >= 100) {
                            filled = true;
                            break;
                        }
                    }
                }
                
                // Check if price is in the FVG zone
                const inZone = currentPrice >= gapLow && currentPrice <= gapHigh;
                
                if (!filled) {
                    bullishFVGs.push({
                        high: gapHigh,
                        low: gapLow,
                        price: (gapHigh + gapLow) / 2,
                        size: gapSize,
                        sizePct: gapPct,
                        index: i + 1,
                        time: candle2.time,
                        filled: filled,
                        fillPct: fillPct,
                        inZone: inZone
                    });
                }
            }
        }
        
        // Bearish FVG: Gap between candle1 low and candle3 high
        if (candle3.high < candle1.low) {
            const gapHigh = candle1.low;
            const gapLow = candle3.high;
            const gapSize = gapHigh - gapLow;
            const gapPct = (gapSize / candle2.close) * 100;
            
            if (gapPct >= 0.1) { // Minimum gap size
                // Check if FVG has been filled
                let filled = false;
                let fillPct = 0;
                
                for (let j = i + 3; j < len; j++) {
                    if (klines[j].high >= gapLow) {
                        const fillAmount = Math.min(klines[j].high, gapHigh) - gapLow;
                        fillPct = Math.min(100, (fillAmount / gapSize) * 100);
                        if (fillPct >= 100) {
                            filled = true;
                            break;
                        }
                    }
                }
                
                // Check if price is in the FVG zone
                const inZone = currentPrice >= gapLow && currentPrice <= gapHigh;
                
                if (!filled) {
                    bearishFVGs.push({
                        high: gapHigh,
                        low: gapLow,
                        price: (gapHigh + gapLow) / 2,
                        size: gapSize,
                        sizePct: gapPct,
                        index: i + 1,
                        time: candle2.time,
                        filled: filled,
                        fillPct: fillPct,
                        inZone: inZone
                    });
                }
            }
        }
    }
    
    // Sort by proximity to current price
    bullishFVGs.sort((a, b) => Math.abs(currentPrice - a.price) - Math.abs(currentPrice - b.price));
    bearishFVGs.sort((a, b) => Math.abs(currentPrice - a.price) - Math.abs(currentPrice - b.price));
    
    return { bullish: bullishFVGs.slice(0, 5), bearish: bearishFVGs.slice(0, 5) };
}


// Detect Equal Highs and Equal Lows (Liquidity Pools)
function detectEqualLevels(klines, tolerance = 0.002) {
    if (!klines || klines.length < 50) return { equalHighs: [], equalLows: [] };
    
    const swings = findSwingPoints(klines, 4, 4);
    const equalHighs = [];
    const equalLows = [];
    
    // Find equal highs
    for (let i = 0; i < swings.highs.length; i++) {
        const matches = [swings.highs[i]];
        
        for (let j = i + 1; j < swings.highs.length; j++) {
            const pctDiff = Math.abs(swings.highs[i].price - swings.highs[j].price) / swings.highs[i].price;
            if (pctDiff <= tolerance) {
                matches.push(swings.highs[j]);
            }
        }
        
        if (matches.length >= 2) {
            const avgPrice = matches.reduce((sum, m) => sum + m.price, 0) / matches.length;
            // Check if not already added
            const exists = equalHighs.some(eh => Math.abs(eh.price - avgPrice) / avgPrice < tolerance);
            if (!exists) {
                equalHighs.push({
                    price: avgPrice,
                    count: matches.length,
                    indices: matches.map(m => m.index),
                    type: 'EQH'
                });
            }
        }
    }
    
    // Find equal lows
    for (let i = 0; i < swings.lows.length; i++) {
        const matches = [swings.lows[i]];
        
        for (let j = i + 1; j < swings.lows.length; j++) {
            const pctDiff = Math.abs(swings.lows[i].price - swings.lows[j].price) / swings.lows[i].price;
            if (pctDiff <= tolerance) {
                matches.push(swings.lows[j]);
            }
        }
        
        if (matches.length >= 2) {
            const avgPrice = matches.reduce((sum, m) => sum + m.price, 0) / matches.length;
            // Check if not already added
            const exists = equalLows.some(el => Math.abs(el.price - avgPrice) / avgPrice < tolerance);
            if (!exists) {
                equalLows.push({
                    price: avgPrice,
                    count: matches.length,
                    indices: matches.map(m => m.index),
                    type: 'EQL'
                });
            }
        }
    }
    
    return { equalHighs, equalLows };
}

// Detect Liquidity Sweep
function detectLiquiditySweep(klines, equalLevels) {
    if (!klines || klines.length < 5 || !equalLevels) return { detected: false };
    
    const len = klines.length;
    const lastCandle = klines[len - 1];
    const prevCandle = klines[len - 2];
    
    // Check sweep of equal highs (bullish reversal setup after sweep)
    for (const eqh of equalLevels.equalHighs) {
        // Wick above EQH but close below (sweep and reject)
        if (lastCandle.high > eqh.price && lastCandle.close < eqh.price && lastCandle.close < lastCandle.open) {
            const wickAbove = lastCandle.high - Math.max(lastCandle.open, lastCandle.close);
            const body = Math.abs(lastCandle.close - lastCandle.open);
            
            if (wickAbove > body * 0.5) {
                return {
                    detected: true,
                    direction: 'BEARISH', // Swept highs = bearish
                    type: 'SWEEP',
                    level: eqh.price,
                    sweepType: 'EQH',
                    significance: eqh.count >= 3 ? 'HIGH' : 'MEDIUM'
                };
            }
        }
    }
    
    // Check sweep of equal lows (bearish reversal setup after sweep)
    for (const eql of equalLevels.equalLows) {
        // Wick below EQL but close above (sweep and reject)
        if (lastCandle.low < eql.price && lastCandle.close > eql.price && lastCandle.close > lastCandle.open) {
            const wickBelow = Math.min(lastCandle.open, lastCandle.close) - lastCandle.low;
            const body = Math.abs(lastCandle.close - lastCandle.open);
            
            if (wickBelow > body * 0.5) {
                return {
                    detected: true,
                    direction: 'BULLISH', // Swept lows = bullish
                    type: 'SWEEP',
                    level: eql.price,
                    sweepType: 'EQL',
                    significance: eql.count >= 3 ? 'HIGH' : 'MEDIUM'
                };
            }
        }
    }
    
    return { detected: false };
}

// Get Premium/Discount Zones
function getPremiumDiscount(klines, lookback = 100) {
    if (!klines || klines.length < lookback) return null;
    
    const recent = klines.slice(-lookback);
    const high = Math.max(...recent.map(k => k.high));
    const low = Math.min(...recent.map(k => k.low));
    const range = high - low;
    const currentPrice = klines[klines.length - 1].close;
    
    const equilibrium = (high + low) / 2;
    const premium = high - range * 0.3;      // Top 30%
    const discount = low + range * 0.3;      // Bottom 30%
    
    let zone;
    if (currentPrice >= premium) zone = 'PREMIUM';
    else if (currentPrice <= discount) zone = 'DISCOUNT';
    else zone = 'EQUILIBRIUM';
    
    const percentFromEQ = ((currentPrice - equilibrium) / equilibrium) * 100;
    const positionPct = ((currentPrice - low) / range) * 100;
    
    return {
        high,
        low,
        equilibrium,
        premium,
        discount,
        currentPrice,
        zone,
        percentFromEQ,
        positionPct,
        favorsBuy: zone === 'DISCOUNT',
        favorsSell: zone === 'PREMIUM'
    };
}

// Detect Kill Zone (Trading Sessions)
function getKillZone() {
    const now = new Date();
    const utcHour = now.getUTCHours();
    
    const sessions = [
        { name: 'ASIA', start: 0, end: 3, color: '#06b6d4', active: false },
        { name: 'LONDON', start: 7, end: 10, color: '#a855f7', active: false },
        { name: 'NY_AM', start: 12, end: 15, color: '#f59e0b', active: false },
        { name: 'NY_PM', start: 15, end: 17, color: '#ef4444', active: false }
    ];
    
    for (const session of sessions) {
        if (utcHour >= session.start && utcHour < session.end) {
            return { ...session, active: true, bonus: session.name === 'LONDON' || session.name === 'NY_AM' ? 10 : 5 };
        }
    }
    
    return { name: 'OFF_SESSION', active: false, bonus: 0, color: '#64748b' };
}

// Signal State Machine
function getSignalState(bos, choch, ob, fvg, currentPrice) {
    // LOCKED: Clear trigger present (BOS or CHoCH)
    if (bos.detected || choch.detected) {
        // Check if we're in pullback to OB or FVG
        const direction = bos.detected ? bos.direction : choch.direction;
        
        if (direction === 'BULLISH') {
            // Check if price pulled back to bullish OB or FVG
            const nearOB = ob.bullish.length > 0 && 
                Math.abs(currentPrice - ob.bullish[0].price) / currentPrice < 0.01;
            const nearFVG = fvg.bullish.length > 0 && 
                (currentPrice >= fvg.bullish[0].low && currentPrice <= fvg.bullish[0].high);
            
            if (nearOB || nearFVG) {
                return { state: 'ENTRY', reason: nearOB ? 'At Bullish OB' : 'In Bullish FVG' };
            }
            return { state: 'PULLBACK', reason: 'Waiting for pullback to OB/FVG' };
        } else {
            // Check if price pulled back to bearish OB or FVG
            const nearOB = ob.bearish.length > 0 && 
                Math.abs(currentPrice - ob.bearish[0].price) / currentPrice < 0.01;
            const nearFVG = fvg.bearish.length > 0 && 
                (currentPrice >= fvg.bearish[0].low && currentPrice <= fvg.bearish[0].high);
            
            if (nearOB || nearFVG) {
                return { state: 'ENTRY', reason: nearOB ? 'At Bearish OB' : 'In Bearish FVG' };
            }
            return { state: 'PULLBACK', reason: 'Waiting for pullback to OB/FVG' };
        }
    }
    
    // FORMING: OB or FVG present but no trigger yet
    if (ob.bullish.length > 0 || ob.bearish.length > 0 || fvg.bullish.length > 0 || fvg.bearish.length > 0) {
        return { state: 'FORMING', reason: 'Waiting for BOS/CHoCH trigger' };
    }
    
    return { state: 'WAITING', reason: 'No setup detected' };
}

// MAIN SMC ANALYSIS FUNCTION
function performSMCAnalysis(klines, tf) {
    const result = {
        score: 0,
        direction: null,
        trigger: null,
        factors: [],
        warnings: [],
        details: {}
    };
    
    if (!klines || klines.length < 50) return result;
    
    const len = klines.length;
    const currentPrice = klines[len - 1].close;
    
    // Get market structure
    const structure = detectStructure(klines);
    result.details.structure = structure;
    result.details.trend = structure.trend;
    
    // Detect BOS
    const bos = detectBOS(klines, structure);
    result.details.bos = bos;
    
    // Detect CHoCH
    const choch = detectCHoCH(klines, structure);
    result.details.choch = choch;
    
    // Detect Order Blocks
    const orderBlocks = detectOrderBlocks(klines);
    result.details.orderBlocks = orderBlocks;
    
    // Detect Breaker Blocks
    const breakerBlocks = detectBreakerBlocks(klines, orderBlocks);
    result.details.breakerBlocks = breakerBlocks;
    
    // Detect FVG
    const fvg = detectFVG(klines);
    result.details.fvg = fvg;
    
    // Detect Equal Levels
    const equalLevels = detectEqualLevels(klines);
    result.details.equalLevels = equalLevels;
    
    // Detect Liquidity Sweep
    const sweep = detectLiquiditySweep(klines, equalLevels);
    result.details.sweep = sweep;
    
    // Get Premium/Discount
    const pdZone = getPremiumDiscount(klines);
    result.details.pdZone = pdZone;
    
    // Get Kill Zone
    const killZone = getKillZone();
    result.details.killZone = killZone;
    
    // Get Signal State
    const signalState = getSignalState(bos, choch, orderBlocks, fvg, currentPrice);
    result.details.signalState = signalState;
    
    // SCORING
    let score = 0;
    let bullScore = 0;
    let bearScore = 0;
    
    // Structure trend (10 points)
    if (structure.trend === 'BULLISH') {
        bullScore += 10;
        result.factors.push('Bullish Structure');
    } else if (structure.trend === 'BEARISH') {
        bearScore += 10;
        result.factors.push('Bearish Structure');
    }
    
    // BOS (25 points)
    if (bos.detected) {
        if (bos.direction === 'BULLISH') {
            bullScore += 25;
            result.factors.push('BOS‚Üë');
            if (bos.strength === 'STRONG') {
                bullScore += 5;
                result.factors.push('Strong BOS');
            }
        } else {
            bearScore += 25;
            result.factors.push('BOS‚Üì');
            if (bos.strength === 'STRONG') {
                bearScore += 5;
                result.factors.push('Strong BOS');
            }
        }
        result.trigger = 'BOS';
    }
    
    // CHoCH (30 points - stronger signal)
    if (choch.detected) {
        if (choch.direction === 'BULLISH') {
            bullScore += 30;
            result.factors.push('CHoCH‚Üë');
        } else {
            bearScore += 30;
            result.factors.push('CHoCH‚Üì');
        }
        result.trigger = result.trigger ? result.trigger + '+CHoCH' : 'CHoCH';
    }
    
    // Order Blocks (15 points)
    if (orderBlocks.bullish.length > 0) {
        const nearestOB = orderBlocks.bullish[0];
        const distance = Math.abs(currentPrice - nearestOB.price) / currentPrice;
        if (distance < 0.01) {
            bullScore += 15;
            result.factors.push(nearestOB.fresh ? 'Fresh Bull OB' : 'Bull OB');
        } else if (distance < 0.02) {
            bullScore += 8;
        }
    }
    if (orderBlocks.bearish.length > 0) {
        const nearestOB = orderBlocks.bearish[0];
        const distance = Math.abs(currentPrice - nearestOB.price) / currentPrice;
        if (distance < 0.01) {
            bearScore += 15;
            result.factors.push(nearestOB.fresh ? 'Fresh Bear OB' : 'Bear OB');
        } else if (distance < 0.02) {
            bearScore += 8;
        }
    }
    
    // Breaker Blocks (12 points)
    if (breakerBlocks.bullish.length > 0) {
        const distance = Math.abs(currentPrice - breakerBlocks.bullish[0].price) / currentPrice;
        if (distance < 0.015) {
            bullScore += 12;
            result.factors.push('Bull Breaker');
        }
    }
    if (breakerBlocks.bearish.length > 0) {
        const distance = Math.abs(currentPrice - breakerBlocks.bearish[0].price) / currentPrice;
        if (distance < 0.015) {
            bearScore += 12;
            result.factors.push('Bear Breaker');
        }
    }
    
    // FVG (10 points)
    if (fvg.bullish.length > 0 && fvg.bullish[0].inZone) {
        bullScore += 10;
        result.factors.push('In Bull FVG');
    }
    if (fvg.bearish.length > 0 && fvg.bearish[0].inZone) {
        bearScore += 10;
        result.factors.push('In Bear FVG');
    }
    
    // Liquidity Sweep (15 points)
    if (sweep.detected) {
        if (sweep.direction === 'BULLISH') {
            bullScore += sweep.significance === 'HIGH' ? 18 : 12;
            result.factors.push('Liq Sweep‚Üë');
        } else {
            bearScore += sweep.significance === 'HIGH' ? 18 : 12;
            result.factors.push('Liq Sweep‚Üì');
        }
        result.trigger = result.trigger ? result.trigger + '+Sweep' : 'Sweep';
    }
    
    // Premium/Discount (10 points)
    if (pdZone) {
        if (pdZone.zone === 'DISCOUNT') {
            bullScore += 10;
            result.factors.push('Discount Zone');
        } else if (pdZone.zone === 'PREMIUM') {
            bearScore += 10;
            result.factors.push('Premium Zone');
        }
    }
    
    // Kill Zone bonus
    if (killZone.active) {
        score += killZone.bonus;
        result.factors.push(killZone.name + ' Session');
    }
    
    // Determine direction and final score
    if (bullScore > bearScore + 10) {
        result.direction = 'LONG';
        score += bullScore;
    } else if (bearScore > bullScore + 10) {
        result.direction = 'SHORT';
        score += bearScore;
    } else {
        // Mixed signals
        score += Math.max(bullScore, bearScore) * 0.5;
        result.warnings.push('Mixed SMC signals');
    }
    
    // Signal state bonus/penalty
    if (signalState.state === 'ENTRY') {
        score += 10;
        result.factors.push(signalState.reason);
    } else if (signalState.state === 'FORMING') {
        result.warnings.push(signalState.reason);
    }
    
    result.score = Math.min(100, Math.max(0, Math.round(score)));
    return result;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// END OF PART 2 - SMC Analysis Complete
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MOMENTUM ANALYSIS ENGINE - COMPLETE IMPLEMENTATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Calculate RSI with Wilder Smoothing (correct implementation)
function calcRSI(closes, period = 14) {
    if (!closes || closes.length < period + 1) return { value: 50, trend: 'NEUTRAL' };
    
    const gains = [];
    const losses = [];
    
    for (let i = 1; i < closes.length; i++) {
        const change = closes[i] - closes[i - 1];
        gains.push(change > 0 ? change : 0);
        losses.push(change < 0 ? -change : 0);
    }
    
    // Initial average (SMA)
    let avgGain = 0;
    let avgLoss = 0;
    for (let i = 0; i < period; i++) {
        avgGain += gains[i];
        avgLoss += losses[i];
    }
    avgGain /= period;
    avgLoss /= period;
    
    // Wilder smoothing for remaining values
    for (let i = period; i < gains.length; i++) {
        avgGain = (avgGain * (period - 1) + gains[i]) / period;
        avgLoss = (avgLoss * (period - 1) + losses[i]) / period;
    }
    
    if (avgLoss === 0) return { value: 100, trend: 'OVERBOUGHT' };
    
    const rs = avgGain / avgLoss;
    const rsi = 100 - (100 / (1 + rs));
    
    let trend = 'NEUTRAL';
    if (rsi >= 70) trend = 'OVERBOUGHT';
    else if (rsi >= 60) trend = 'BULLISH';
    else if (rsi <= 30) trend = 'OVERSOLD';
    else if (rsi <= 40) trend = 'BEARISH';
    
    return { value: rsi, trend, avgGain, avgLoss };
}

// Calculate MACD with Signal Line and Histogram
function calcMACD(closes, fastPeriod = 12, slowPeriod = 26, signalPeriod = 9) {
    if (!closes || closes.length < slowPeriod + signalPeriod) {
        return { macd: 0, signal: 0, histogram: 0, trend: 'NEUTRAL', crossover: null };
    }
    
    // Calculate EMAs
    const calcEMA = (data, period) => {
        const k = 2 / (period + 1);
        let ema = data[0];
        const emaValues = [ema];
        
        for (let i = 1; i < data.length; i++) {
            ema = data[i] * k + ema * (1 - k);
            emaValues.push(ema);
        }
        return emaValues;
    };
    
    const ema12 = calcEMA(closes, fastPeriod);
    const ema26 = calcEMA(closes, slowPeriod);
    
    // MACD Line
    const macdLine = [];
    for (let i = 0; i < closes.length; i++) {
        macdLine.push(ema12[i] - ema26[i]);
    }
    
    // Signal Line (EMA of MACD)
    const signalLine = calcEMA(macdLine.slice(slowPeriod - 1), signalPeriod);
    
    const currentMACD = macdLine[macdLine.length - 1];
    const currentSignal = signalLine[signalLine.length - 1];
    const prevMACD = macdLine[macdLine.length - 2];
    const prevSignal = signalLine[signalLine.length - 2];
    const histogram = currentMACD - currentSignal;
    const prevHistogram = prevMACD - prevSignal;
    
    // Detect crossover
    let crossover = null;
    if (prevMACD <= prevSignal && currentMACD > currentSignal) {
        crossover = 'BULLISH';
    } else if (prevMACD >= prevSignal && currentMACD < currentSignal) {
        crossover = 'BEARISH';
    }
    
    // Histogram momentum
    let histogramTrend = 'NEUTRAL';
    if (histogram > 0 && histogram > prevHistogram) histogramTrend = 'BULLISH_EXPANDING';
    else if (histogram > 0 && histogram < prevHistogram) histogramTrend = 'BULLISH_CONTRACTING';
    else if (histogram < 0 && histogram < prevHistogram) histogramTrend = 'BEARISH_EXPANDING';
    else if (histogram < 0 && histogram > prevHistogram) histogramTrend = 'BEARISH_CONTRACTING';
    
    let trend = 'NEUTRAL';
    if (currentMACD > 0 && currentMACD > currentSignal) trend = 'BULLISH';
    else if (currentMACD < 0 && currentMACD < currentSignal) trend = 'BEARISH';
    
    return {
        macd: currentMACD,
        signal: currentSignal,
        histogram,
        histogramTrend,
        trend,
        crossover,
        ema12: ema12[ema12.length - 1],
        ema26: ema26[ema26.length - 1]
    };
}

// Calculate ADX with DI+ and DI-
function calcADX(klines, period = 14) {
    if (!klines || klines.length < period * 2) {
        return { adx: 0, diPlus: 0, diMinus: 0, trend: 'NEUTRAL', strength: 'WEAK' };
    }
    
    const plusDM = [];
    const minusDM = [];
    const tr = [];
    
    for (let i = 1; i < klines.length; i++) {
        const high = klines[i].high;
        const low = klines[i].low;
        const prevHigh = klines[i - 1].high;
        const prevLow = klines[i - 1].low;
        const prevClose = klines[i - 1].close;
        
        // Directional Movement
        const upMove = high - prevHigh;
        const downMove = prevLow - low;
        
        plusDM.push(upMove > downMove && upMove > 0 ? upMove : 0);
        minusDM.push(downMove > upMove && downMove > 0 ? downMove : 0);
        
        // True Range
        tr.push(Math.max(
            high - low,
            Math.abs(high - prevClose),
            Math.abs(low - prevClose)
        ));
    }
    
    // Smoothed values
    let smoothPlusDM = 0;
    let smoothMinusDM = 0;
    let smoothTR = 0;
    
    for (let i = 0; i < period; i++) {
        smoothPlusDM += plusDM[i];
        smoothMinusDM += minusDM[i];
        smoothTR += tr[i];
    }
    
    const dxValues = [];
    
    for (let i = period; i < plusDM.length; i++) {
        smoothPlusDM = smoothPlusDM - smoothPlusDM / period + plusDM[i];
        smoothMinusDM = smoothMinusDM - smoothMinusDM / period + minusDM[i];
        smoothTR = smoothTR - smoothTR / period + tr[i];
        
        const diPlus = smoothTR > 0 ? (smoothPlusDM / smoothTR) * 100 : 0;
        const diMinus = smoothTR > 0 ? (smoothMinusDM / smoothTR) * 100 : 0;
        const diSum = diPlus + diMinus;
        const dx = diSum > 0 ? Math.abs(diPlus - diMinus) / diSum * 100 : 0;
        
        dxValues.push({ dx, diPlus, diMinus });
    }
    
    if (dxValues.length < period) {
        return { adx: 0, diPlus: 0, diMinus: 0, trend: 'NEUTRAL', strength: 'WEAK' };
    }
    
    // ADX (smoothed DX)
    let adx = 0;
    for (let i = 0; i < period; i++) {
        adx += dxValues[i].dx;
    }
    adx /= period;
    
    for (let i = period; i < dxValues.length; i++) {
        adx = (adx * (period - 1) + dxValues[i].dx) / period;
    }
    
    const lastDI = dxValues[dxValues.length - 1];
    const prevDI = dxValues[dxValues.length - 2];
    
    // Trend direction and strength
    let trend = 'NEUTRAL';
    if (lastDI.diPlus > lastDI.diMinus) trend = 'BULLISH';
    else if (lastDI.diMinus > lastDI.diPlus) trend = 'BEARISH';
    
    let strength = 'WEAK';
    if (adx >= 50) strength = 'VERY_STRONG';
    else if (adx >= 35) strength = 'STRONG';
    else if (adx >= 25) strength = 'TRENDING';
    else if (adx >= 20) strength = 'WEAK_TREND';
    
    // DI crossover detection
    let crossover = null;
    if (prevDI.diPlus <= prevDI.diMinus && lastDI.diPlus > lastDI.diMinus) {
        crossover = 'BULLISH';
    } else if (prevDI.diPlus >= prevDI.diMinus && lastDI.diPlus < lastDI.diMinus) {
        crossover = 'BEARISH';
    }
    
    return {
        adx,
        diPlus: lastDI.diPlus,
        diMinus: lastDI.diMinus,
        trend,
        strength,
        crossover,
        trending: adx >= 25
    };
}

// Calculate Stochastic RSI
function calcStochRSI(closes, rsiPeriod = 14, stochPeriod = 14, kPeriod = 3, dPeriod = 3) {
    if (!closes || closes.length < rsiPeriod + stochPeriod + kPeriod) {
        return { k: 50, d: 50, trend: 'NEUTRAL', crossover: null };
    }
    
    // Calculate RSI values
    const rsiValues = [];
    for (let i = rsiPeriod; i < closes.length; i++) {
        const rsi = calcRSI(closes.slice(0, i + 1), rsiPeriod);
        rsiValues.push(rsi.value);
    }
    
    if (rsiValues.length < stochPeriod) {
        return { k: 50, d: 50, trend: 'NEUTRAL', crossover: null };
    }
    
    // Calculate Stochastic of RSI
    const stochRSI = [];
    for (let i = stochPeriod - 1; i < rsiValues.length; i++) {
        const period = rsiValues.slice(i - stochPeriod + 1, i + 1);
        const minRSI = Math.min(...period);
        const maxRSI = Math.max(...period);
        const range = maxRSI - minRSI;
        
        if (range === 0) {
            stochRSI.push(50);
        } else {
            stochRSI.push(((rsiValues[i] - minRSI) / range) * 100);
        }
    }
    
    // Calculate %K (SMA of Stochastic RSI)
    const kValues = [];
    for (let i = kPeriod - 1; i < stochRSI.length; i++) {
        const sum = stochRSI.slice(i - kPeriod + 1, i + 1).reduce((a, b) => a + b, 0);
        kValues.push(sum / kPeriod);
    }
    
    // Calculate %D (SMA of %K)
    const dValues = [];
    for (let i = dPeriod - 1; i < kValues.length; i++) {
        const sum = kValues.slice(i - dPeriod + 1, i + 1).reduce((a, b) => a + b, 0);
        dValues.push(sum / dPeriod);
    }
    
    const k = kValues[kValues.length - 1] || 50;
    const d = dValues[dValues.length - 1] || 50;
    const prevK = kValues[kValues.length - 2] || 50;
    const prevD = dValues[dValues.length - 2] || 50;
    
    // Crossover detection
    let crossover = null;
    if (prevK <= prevD && k > d) crossover = 'BULLISH';
    else if (prevK >= prevD && k < d) crossover = 'BEARISH';
    
    let trend = 'NEUTRAL';
    if (k >= 80) trend = 'OVERBOUGHT';
    else if (k <= 20) trend = 'OVERSOLD';
    else if (k > d && k > 50) trend = 'BULLISH';
    else if (k < d && k < 50) trend = 'BEARISH';
    
    return { k, d, trend, crossover };
}

// Calculate On-Balance Volume (OBV) with trend
function calcOBV(klines) {
    if (!klines || klines.length < 20) {
        return { obv: 0, trend: 'NEUTRAL', divergence: null };
    }
    
    let obv = 0;
    const obvValues = [0];
    
    for (let i = 1; i < klines.length; i++) {
        if (klines[i].close > klines[i - 1].close) {
            obv += klines[i].volume;
        } else if (klines[i].close < klines[i - 1].close) {
            obv -= klines[i].volume;
        }
        obvValues.push(obv);
    }
    
    // Calculate OBV trend using EMA
    const len = obvValues.length;
    const shortEMA = obvValues.slice(-10).reduce((a, b) => a + b, 0) / 10;
    const longEMA = obvValues.slice(-20).reduce((a, b) => a + b, 0) / 20;
    
    let trend = 'NEUTRAL';
    if (shortEMA > longEMA * 1.05) trend = 'BULLISH';
    else if (shortEMA < longEMA * 0.95) trend = 'BEARISH';
    
    // Check for OBV divergence with price
    const recentOBV = obvValues.slice(-20);
    const recentClose = klines.slice(-20).map(k => k.close);
    
    const priceUp = recentClose[recentClose.length - 1] > recentClose[0];
    const obvUp = recentOBV[recentOBV.length - 1] > recentOBV[0];
    
    let divergence = null;
    if (priceUp && !obvUp) divergence = 'BEARISH'; // Price up, OBV down
    else if (!priceUp && obvUp) divergence = 'BULLISH'; // Price down, OBV up
    
    return {
        obv: obvValues[obvValues.length - 1],
        obvValues,
        trend,
        divergence,
        shortEMA,
        longEMA
    };
}

// Calculate Volume Metrics
function calcVolumeMetrics(klines) {
    if (!klines || klines.length < 25) {
        return { ratio: 1, spike: false, trend: 'NEUTRAL' };
    }
    
    const len = klines.length;
    const currentVolume = klines[len - 1].volume;
    
    // Average volume (20 period)
    const avgVolume = klines.slice(-21, -1).reduce((sum, k) => sum + k.volume, 0) / 20;
    
    const ratio = avgVolume > 0 ? currentVolume / avgVolume : 1;
    const spike = ratio >= 2.5;
    
    // Volume trend
    const recentAvg = klines.slice(-5).reduce((sum, k) => sum + k.volume, 0) / 5;
    const olderAvg = klines.slice(-15, -10).reduce((sum, k) => sum + k.volume, 0) / 5;
    
    let trend = 'NEUTRAL';
    if (recentAvg > olderAvg * 1.3) trend = 'INCREASING';
    else if (recentAvg < olderAvg * 0.7) trend = 'DECREASING';
    
    return {
        current: currentVolume,
        average: avgVolume,
        ratio,
        spike,
        trend,
        percentAboveAvg: ((ratio - 1) * 100)
    };
}


// Calculate EMA values
function calcEMA(closes, period) {
    if (!closes || closes.length < period) return null;
    
    const k = 2 / (period + 1);
    let ema = closes.slice(0, period).reduce((a, b) => a + b, 0) / period;
    
    for (let i = period; i < closes.length; i++) {
        ema = closes[i] * k + ema * (1 - k);
    }
    
    return ema;
}

// Get EMA Cross signals (9/21 for scalping, 50/200 for trend)
function getEMACross(closes) {
    if (!closes || closes.length < 200) {
        return { 
            ema9: 0, ema21: 0, ema50: 0, ema200: 0,
            shortCross: null, longCross: null, 
            priceVsEMA: 'NEUTRAL'
        };
    }
    
    const ema9 = calcEMA(closes, 9);
    const ema21 = calcEMA(closes, 21);
    const ema50 = calcEMA(closes, 50);
    const ema200 = calcEMA(closes, 200);
    const currentPrice = closes[closes.length - 1];
    
    // Calculate previous EMAs for crossover detection
    const prevCloses = closes.slice(0, -1);
    const prevEma9 = calcEMA(prevCloses, 9);
    const prevEma21 = calcEMA(prevCloses, 21);
    const prevEma50 = calcEMA(prevCloses, 50);
    const prevEma200 = calcEMA(prevCloses, 200);
    
    // Short-term cross (9/21)
    let shortCross = null;
    if (prevEma9 <= prevEma21 && ema9 > ema21) shortCross = 'BULLISH';
    else if (prevEma9 >= prevEma21 && ema9 < ema21) shortCross = 'BEARISH';
    
    // Long-term cross (50/200 - Golden/Death Cross)
    let longCross = null;
    if (prevEma50 <= prevEma200 && ema50 > ema200) longCross = 'GOLDEN';
    else if (prevEma50 >= prevEma200 && ema50 < ema200) longCross = 'DEATH';
    
    // Price position vs EMAs
    let priceVsEMA = 'NEUTRAL';
    if (currentPrice > ema9 && currentPrice > ema21 && currentPrice > ema50) {
        priceVsEMA = 'STRONG_BULLISH';
    } else if (currentPrice > ema9 && currentPrice > ema21) {
        priceVsEMA = 'BULLISH';
    } else if (currentPrice < ema9 && currentPrice < ema21 && currentPrice < ema50) {
        priceVsEMA = 'STRONG_BEARISH';
    } else if (currentPrice < ema9 && currentPrice < ema21) {
        priceVsEMA = 'BEARISH';
    }
    
    return {
        ema9, ema21, ema50, ema200,
        shortCross, longCross,
        priceVsEMA,
        aboveEMA200: currentPrice > ema200,
        aboveEMA50: currentPrice > ema50
    };
}

// Detect Divergence (Regular, Hidden, Compound)
function detectDivergence(klines, indicatorFn = 'rsi') {
    if (!klines || klines.length < 50) {
        return { type: null, strength: null, direction: null };
    }
    
    const closes = klines.map(k => k.close);
    const highs = klines.map(k => k.high);
    const lows = klines.map(k => k.low);
    
    // Find swing points in price
    const priceSwings = findSwingPoints(klines, 4, 4);
    
    // Calculate indicator values
    let indicatorValues = [];
    if (indicatorFn === 'rsi') {
        for (let i = 14; i < closes.length; i++) {
            indicatorValues.push({
                index: i,
                value: calcRSI(closes.slice(0, i + 1), 14).value
            });
        }
    } else if (indicatorFn === 'macd') {
        for (let i = 35; i < closes.length; i++) {
            indicatorValues.push({
                index: i,
                value: calcMACD(closes.slice(0, i + 1)).histogram
            });
        }
    }
    
    if (indicatorValues.length < 20 || priceSwings.highs.length < 2 || priceSwings.lows.length < 2) {
        return { type: null, strength: null, direction: null };
    }
    
    // Get indicator values at swing points
    const getIndicatorAtIndex = (idx) => {
        const found = indicatorValues.find(v => v.index === idx);
        if (found) return found.value;
        // Find closest
        const closest = indicatorValues.reduce((prev, curr) => 
            Math.abs(curr.index - idx) < Math.abs(prev.index - idx) ? curr : prev
        );
        return closest.value;
    };
    
    // Check for Regular Bullish Divergence (price lower low, indicator higher low)
    const recentLows = priceSwings.lows.slice(-4);
    for (let i = 0; i < recentLows.length - 1; i++) {
        const firstLow = recentLows[i];
        const secondLow = recentLows[i + 1];
        
        const ind1 = getIndicatorAtIndex(firstLow.index);
        const ind2 = getIndicatorAtIndex(secondLow.index);
        
        // Price makes lower low, indicator makes higher low
        if (secondLow.price < firstLow.price && ind2 > ind1) {
            // Check for compound (3+ swings)
            if (i > 0) {
                const thirdLow = recentLows[i - 1];
                const ind0 = getIndicatorAtIndex(thirdLow.index);
                if (thirdLow.price > firstLow.price && ind0 < ind1) {
                    return { type: 'COMPOUND', strength: 'STRONG', direction: 'BULLISH' };
                }
            }
            return { type: 'REGULAR', strength: 'MEDIUM', direction: 'BULLISH' };
        }
        
        // Hidden Bullish: price higher low, indicator lower low
        if (secondLow.price > firstLow.price && ind2 < ind1) {
            return { type: 'HIDDEN', strength: 'MEDIUM', direction: 'BULLISH' };
        }
    }
    
    // Check for Regular Bearish Divergence (price higher high, indicator lower high)
    const recentHighs = priceSwings.highs.slice(-4);
    for (let i = 0; i < recentHighs.length - 1; i++) {
        const firstHigh = recentHighs[i];
        const secondHigh = recentHighs[i + 1];
        
        const ind1 = getIndicatorAtIndex(firstHigh.index);
        const ind2 = getIndicatorAtIndex(secondHigh.index);
        
        // Price makes higher high, indicator makes lower high
        if (secondHigh.price > firstHigh.price && ind2 < ind1) {
            // Check for compound
            if (i > 0) {
                const thirdHigh = recentHighs[i - 1];
                const ind0 = getIndicatorAtIndex(thirdHigh.index);
                if (thirdHigh.price < firstHigh.price && ind0 > ind1) {
                    return { type: 'COMPOUND', strength: 'STRONG', direction: 'BEARISH' };
                }
            }
            return { type: 'REGULAR', strength: 'MEDIUM', direction: 'BEARISH' };
        }
        
        // Hidden Bearish: price lower high, indicator higher high
        if (secondHigh.price < firstHigh.price && ind2 > ind1) {
            return { type: 'HIDDEN', strength: 'MEDIUM', direction: 'BEARISH' };
        }
    }
    
    return { type: null, strength: null, direction: null };
}

// Detect Momentum Exhaustion
function detectExhaustion(klines, rsi, macd, volume) {
    if (!klines || klines.length < 20) {
        return { detected: false };
    }
    
    const len = klines.length;
    const currentCandle = klines[len - 1];
    const isBullishCandle = currentCandle.close > currentCandle.open;
    
    // Bullish Exhaustion: RSI overbought + volume spike + small body or doji
    if (rsi.value >= 70 && volume.spike) {
        const body = Math.abs(currentCandle.close - currentCandle.open);
        const range = currentCandle.high - currentCandle.low;
        const bodyRatio = range > 0 ? body / range : 0;
        
        if (bodyRatio < 0.3) { // Small body (doji-like)
            return {
                detected: true,
                direction: 'BEARISH', // Bullish exhaustion = bearish signal
                reason: 'RSI OB + Vol spike + weak candle'
            };
        }
        
        // Check for shooting star / hanging man
        const upperWick = currentCandle.high - Math.max(currentCandle.open, currentCandle.close);
        if (upperWick > body * 2) {
            return {
                detected: true,
                direction: 'BEARISH',
                reason: 'Rejection candle at RSI OB'
            };
        }
    }
    
    // Bearish Exhaustion: RSI oversold + volume spike + small body
    if (rsi.value <= 30 && volume.spike) {
        const body = Math.abs(currentCandle.close - currentCandle.open);
        const range = currentCandle.high - currentCandle.low;
        const bodyRatio = range > 0 ? body / range : 0;
        
        if (bodyRatio < 0.3) {
            return {
                detected: true,
                direction: 'BULLISH', // Bearish exhaustion = bullish signal
                reason: 'RSI OS + Vol spike + weak candle'
            };
        }
        
        // Check for hammer
        const lowerWick = Math.min(currentCandle.open, currentCandle.close) - currentCandle.low;
        if (lowerWick > body * 2) {
            return {
                detected: true,
                direction: 'BULLISH',
                reason: 'Hammer candle at RSI OS'
            };
        }
    }
    
    // MACD histogram exhaustion
    if (macd.histogramTrend === 'BULLISH_CONTRACTING' && rsi.value > 65) {
        return {
            detected: true,
            direction: 'BEARISH',
            reason: 'MACD momentum fading'
        };
    }
    
    if (macd.histogramTrend === 'BEARISH_CONTRACTING' && rsi.value < 35) {
        return {
            detected: true,
            direction: 'BULLISH',
            reason: 'MACD momentum fading'
        };
    }
    
    return { detected: false };
}

// Calculate ATR for volatility
function calcATR(klines, period = 14) {
    if (!klines || klines.length < period + 1) return 0;
    
    const tr = [];
    for (let i = 1; i < klines.length; i++) {
        tr.push(Math.max(
            klines[i].high - klines[i].low,
            Math.abs(klines[i].high - klines[i - 1].close),
            Math.abs(klines[i].low - klines[i - 1].close)
        ));
    }
    
    // Wilder smoothing
    let atr = tr.slice(0, period).reduce((a, b) => a + b, 0) / period;
    
    for (let i = period; i < tr.length; i++) {
        atr = (atr * (period - 1) + tr[i]) / period;
    }
    
    return atr;
}

// MAIN MOMENTUM ANALYSIS FUNCTION
function performMomentumAnalysis(klines) {
    const result = {
        score: 0,
        direction: null,
        factors: [],
        warnings: [],
        details: {}
    };
    
    if (!klines || klines.length < 50) return result;
    
    const closes = klines.map(k => k.close);
    
    // Calculate all indicators
    const rsi = calcRSI(closes, 14);
    result.details.rsi = rsi;
    
    const macd = calcMACD(closes);
    result.details.macd = macd;
    
    const adx = calcADX(klines, 14);
    result.details.adx = adx;
    
    const stochRSI = calcStochRSI(closes);
    result.details.stochRSI = stochRSI;
    
    const obv = calcOBV(klines);
    result.details.obv = obv;
    
    const volume = calcVolumeMetrics(klines);
    result.details.volume = volume;
    
    const emaCross = getEMACross(closes);
    result.details.emaCross = emaCross;
    
    const divergenceRSI = detectDivergence(klines, 'rsi');
    const divergenceMACD = detectDivergence(klines, 'macd');
    result.details.divergence = { rsi: divergenceRSI, macd: divergenceMACD };
    
    const exhaustion = detectExhaustion(klines, rsi, macd, volume);
    result.details.exhaustion = exhaustion;
    
    const atr = calcATR(klines);
    result.details.atr = atr;
    
    // SCORING
    let bullScore = 0;
    let bearScore = 0;
    
    // RSI (max 25 points)
    if (rsi.value <= 30) {
        bullScore += 25;
        result.factors.push(`RSI OS(${rsi.value.toFixed(0)})`);
    } else if (rsi.value <= 40) {
        bullScore += 12;
        result.factors.push(`RSI Low(${rsi.value.toFixed(0)})`);
    } else if (rsi.value >= 70) {
        bearScore += 25;
        result.factors.push(`RSI OB(${rsi.value.toFixed(0)})`);
    } else if (rsi.value >= 60) {
        bearScore += 12;
        result.factors.push(`RSI High(${rsi.value.toFixed(0)})`);
    }
    
    // MACD (max 20 points)
    if (macd.crossover === 'BULLISH') {
        bullScore += 20;
        result.factors.push('MACD Cross‚Üë');
    } else if (macd.crossover === 'BEARISH') {
        bearScore += 20;
        result.factors.push('MACD Cross‚Üì');
    } else if (macd.trend === 'BULLISH') {
        bullScore += 10;
        result.factors.push('MACD+');
    } else if (macd.trend === 'BEARISH') {
        bearScore += 10;
        result.factors.push('MACD-');
    }
    
    // MACD Histogram momentum
    if (macd.histogramTrend === 'BULLISH_EXPANDING') {
        bullScore += 8;
        result.factors.push('Hist‚Üë‚Üë');
    } else if (macd.histogramTrend === 'BEARISH_EXPANDING') {
        bearScore += 8;
        result.factors.push('Hist‚Üì‚Üì');
    }
    
    // ADX (max 15 points)
    if (adx.trending) {
        if (adx.trend === 'BULLISH') {
            bullScore += 15;
            result.factors.push(`ADX‚Üë(${adx.adx.toFixed(0)})`);
        } else if (adx.trend === 'BEARISH') {
            bearScore += 15;
            result.factors.push(`ADX‚Üì(${adx.adx.toFixed(0)})`);
        }
        
        if (adx.crossover === 'BULLISH') {
            bullScore += 8;
            result.factors.push('DI+ Cross');
        } else if (adx.crossover === 'BEARISH') {
            bearScore += 8;
            result.factors.push('DI- Cross');
        }
    } else {
        result.warnings.push('Weak trend (ADX<25)');
    }
    
    // Stochastic RSI (max 15 points)
    if (stochRSI.trend === 'OVERSOLD') {
        bullScore += 12;
        result.factors.push('StochRSI OS');
    } else if (stochRSI.trend === 'OVERBOUGHT') {
        bearScore += 12;
        result.factors.push('StochRSI OB');
    }
    
    if (stochRSI.crossover === 'BULLISH' && stochRSI.k < 30) {
        bullScore += 10;
        result.factors.push('StochRSI Cross‚Üë');
    } else if (stochRSI.crossover === 'BEARISH' && stochRSI.k > 70) {
        bearScore += 10;
        result.factors.push('StochRSI Cross‚Üì');
    }
    
    // OBV (max 10 points)
    if (obv.trend === 'BULLISH') {
        bullScore += 8;
        result.factors.push('OBV+');
    } else if (obv.trend === 'BEARISH') {
        bearScore += 8;
        result.factors.push('OBV-');
    }
    
    if (obv.divergence === 'BULLISH') {
        bullScore += 10;
        result.factors.push('OBV Div‚Üë');
    } else if (obv.divergence === 'BEARISH') {
        bearScore += 10;
        result.factors.push('OBV Div‚Üì');
    }
    
    // Volume (max 10 points)
    if (volume.spike) {
        result.factors.push(`Vol Spike(${volume.ratio.toFixed(1)}x)`);
        // Volume confirms direction
    }
    
    // EMA Cross (max 12 points)
    if (emaCross.shortCross === 'BULLISH') {
        bullScore += 12;
        result.factors.push('EMA 9/21‚Üë');
    } else if (emaCross.shortCross === 'BEARISH') {
        bearScore += 12;
        result.factors.push('EMA 9/21‚Üì');
    }
    
    if (emaCross.priceVsEMA === 'STRONG_BULLISH') {
        bullScore += 8;
    } else if (emaCross.priceVsEMA === 'STRONG_BEARISH') {
        bearScore += 8;
    }
    
    if (emaCross.longCross === 'GOLDEN') {
        bullScore += 15;
        result.factors.push('Golden Cross!');
    } else if (emaCross.longCross === 'DEATH') {
        bearScore += 15;
        result.factors.push('Death Cross!');
    }
    
    // Divergence (max 25 points)
    const div = divergenceRSI.type ? divergenceRSI : divergenceMACD;
    if (div.type) {
        const divPoints = div.type === 'COMPOUND' ? 25 : div.type === 'REGULAR' ? 18 : 10;
        if (div.direction === 'BULLISH') {
            bullScore += divPoints;
            result.factors.push(`${div.type} Div‚Üë`);
        } else {
            bearScore += divPoints;
            result.factors.push(`${div.type} Div‚Üì`);
        }
    }
    
    // Exhaustion (warning)
    if (exhaustion.detected) {
        result.warnings.push(exhaustion.reason);
        if (exhaustion.direction === 'BULLISH') {
            bullScore += 5;
        } else {
            bearScore += 5;
        }
    }
    
    // Determine direction
    if (bullScore > bearScore + 10) {
        result.direction = 'LONG';
        result.score = Math.min(100, bullScore);
    } else if (bearScore > bullScore + 10) {
        result.direction = 'SHORT';
        result.score = Math.min(100, bearScore);
    } else {
        result.direction = null;
        result.score = Math.min(100, Math.max(bullScore, bearScore) * 0.6);
        result.warnings.push('Mixed momentum signals');
    }
    
    return result;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// END OF PART 3 - Momentum Analysis Complete
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MASTER INTEGRATION ENGINE - WEIGHTED AVERAGE SCORING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// HTF Bias Analysis
async function analyzeHTFBias(symbol, entryTF, direction) {
    const htfList = CONFIG.HTF_MAP[entryTF] || ['60', '240', 'D'];
    const result = {
        aligned: 0,
        total: htfList.length,
        bias: {},
        score: 0
    };
    
    for (const tf of htfList) {
        try {
            const klines = await fetchKlines(symbol, tf, 100);
            if (!klines || klines.length < 50) {
                result.bias[CONFIG.TF_LABELS[tf] || tf] = 'N/A';
                continue;
            }
            
            const closes = klines.map(k => k.close);
            const currentPrice = closes[closes.length - 1];
            
            // EMA 20 for trend
            const ema20 = calcEMA(closes, 20);
            // EMA 50 for stronger trend
            const ema50 = calcEMA(closes, 50);
            
            // Structure analysis
            const structure = detectStructure(klines);
            
            let bias = 'NEUTRAL';
            let biasStrength = 0;
            
            // Price above both EMAs = bullish
            if (currentPrice > ema20 && currentPrice > ema50 && structure.trend === 'BULLISH') {
                bias = 'BULLISH';
                biasStrength = 2;
            } else if (currentPrice > ema20 && currentPrice > ema50) {
                bias = 'BULLISH';
                biasStrength = 1;
            } else if (currentPrice < ema20 && currentPrice < ema50 && structure.trend === 'BEARISH') {
                bias = 'BEARISH';
                biasStrength = 2;
            } else if (currentPrice < ema20 && currentPrice < ema50) {
                bias = 'BEARISH';
                biasStrength = 1;
            }
            
            result.bias[CONFIG.TF_LABELS[tf] || tf] = bias;
            
            // Check alignment with entry direction
            if ((direction === 'LONG' && bias === 'BULLISH') ||
                (direction === 'SHORT' && bias === 'BEARISH')) {
                result.aligned++;
            }
            
            await sleep(50);
        } catch (e) {
            console.error(`HTF analysis error for ${tf}:`, e);
            result.bias[CONFIG.TF_LABELS[tf] || tf] = 'ERR';
        }
    }
    
    // Score based on alignment
    if (result.aligned === result.total) {
        result.score = 30; // Full alignment bonus
    } else if (result.aligned >= result.total - 1) {
        result.score = 20;
    } else if (result.aligned >= 1) {
        result.score = 10;
    }
    
    return result;
}

// Detect Conflicts between analyses
function detectConflicts(zone, smc, momentum) {
    const conflicts = [];
    let penalty = 0;
    
    // Zone vs SMC direction conflict
    if (zone.direction && smc.direction && zone.direction !== smc.direction) {
        conflicts.push('Zone vs SMC conflict');
        penalty += CONFIG.PENALTIES.ZONE_SMC_CONFLICT;
    }
    
    // SMC bullish but RSI overbought (exhaustion risk)
    if (smc.direction === 'LONG' && momentum.details.rsi && momentum.details.rsi.value >= 75) {
        conflicts.push('RSI exhaustion risk');
        penalty += CONFIG.PENALTIES.EXHAUSTION;
    }
    
    // SMC bearish but RSI oversold (exhaustion risk)
    if (smc.direction === 'SHORT' && momentum.details.rsi && momentum.details.rsi.value <= 25) {
        conflicts.push('RSI exhaustion risk');
        penalty += CONFIG.PENALTIES.EXHAUSTION;
    }
    
    // Divergence against trade direction
    const div = momentum.details.divergence;
    if (div) {
        if (smc.direction === 'LONG' && (div.rsi.direction === 'BEARISH' || div.macd.direction === 'BEARISH')) {
            conflicts.push('Divergence against long');
            penalty += CONFIG.PENALTIES.DIVERGENCE_AGAINST;
        }
        if (smc.direction === 'SHORT' && (div.rsi.direction === 'BULLISH' || div.macd.direction === 'BULLISH')) {
            conflicts.push('Divergence against short');
            penalty += CONFIG.PENALTIES.DIVERGENCE_AGAINST;
        }
    }
    
    return { conflicts, penalty };
}

// Calculate Trade Levels
function calculateTradeLevels(currentPrice, direction, atr, zoneDetails, smcDetails, adx) {
    let entry = currentPrice;
    let sl, tp1, tp2, tp3;
    
    const atrMultiplier = 2.0;
    
    // Calculate Smart Limit Entry
    const limitData = calculateSmartLimitEntry(currentPrice, direction, atr, zoneDetails, smcDetails, adx);
    
    if (direction === 'LONG') {
        // Stop loss below support or ATR-based
        if (zoneDetails.nearestSupport) {
            sl = Math.min(
                zoneDetails.nearestSupport.low * 0.998,
                currentPrice - atr * atrMultiplier
            );
        } else {
            sl = currentPrice - atr * atrMultiplier;
        }
        
        // Take profit levels
        const risk = entry - sl;
        tp1 = entry + risk * 1.5;  // 1:1.5 RR
        tp2 = entry + risk * 2.5;  // 1:2.5 RR
        tp3 = entry + risk * 4.0;  // 1:4 RR
        
        // Adjust TP if near resistance - ONLY if resistance is ABOVE calculated TP
        if (zoneDetails.nearestResistance && zoneDetails.nearestResistance.low > entry) {
            tp1 = Math.min(tp1, zoneDetails.nearestResistance.low * 0.998);
            // Ensure TP1 is still above entry
            if (tp1 <= entry) {
                tp1 = entry + risk * 1.5;
            }
        }
        
    } else { // SHORT
        // Stop loss above resistance or ATR-based
        if (zoneDetails.nearestResistance) {
            sl = Math.max(
                zoneDetails.nearestResistance.high * 1.002,
                currentPrice + atr * atrMultiplier
            );
        } else {
            sl = currentPrice + atr * atrMultiplier;
        }
        
        // Take profit levels
        const risk = sl - entry;
        tp1 = entry - risk * 1.5;
        tp2 = entry - risk * 2.5;
        tp3 = entry - risk * 4.0;
        
        // Adjust TP if near support - ONLY if support is BELOW calculated TP
        if (zoneDetails.nearestSupport && zoneDetails.nearestSupport.high < entry) {
            tp1 = Math.max(tp1, zoneDetails.nearestSupport.high * 1.002);
            // Ensure TP1 is still below entry
            if (tp1 >= entry) {
                tp1 = entry - risk * 1.5;
            }
        }
    }
    
    const risk = Math.abs(entry - sl);
    const reward = Math.abs(tp2 - entry);
    const rr = risk > 0 ? (reward / risk).toFixed(2) : '0';
    
    // Calculate R:R for limit entry
    const limitRisk = Math.abs(limitData.limitEntry - sl);
    const limitReward = Math.abs(tp2 - limitData.limitEntry);
    const limitRR = limitRisk > 0 ? (limitReward / limitRisk).toFixed(2) : '0';
    
    return {
        entry,
        limitEntry: limitData.limitEntry,
        limitType: limitData.entryType,
        limitConfidence: limitData.confidence,
        sl,
        tp1,
        tp2,
        tp3,
        rr,
        limitRR,
        risk,
        reward,
        riskPct: ((risk / entry) * 100).toFixed(2)
    };
}

// MASTER SIGNAL ANALYSIS - Combines all three engines
async function analyzeSignal(symbol, tf) {
    try {
        // Fetch klines
        const klines = await fetchKlines(symbol, tf, 200);
        if (!klines || klines.length < 100) return null;
        
        const currentPrice = klines[klines.length - 1].close;
        const atr = calcATR(klines);
        
        // Run all three analyses
        const zoneAnalysis = await performZoneAnalysis(klines, symbol, tf, currentPrice);
        const smcAnalysis = performSMCAnalysis(klines, tf);
        const momentumAnalysis = performMomentumAnalysis(klines);
        
        // Determine primary direction (voting system)
        let votes = { LONG: 0, SHORT: 0 };
        
        // Track individual engine directions for agreement display
        const engineDirections = {
            zone: zoneAnalysis.direction,
            smc: smcAnalysis.direction,
            momentum: momentumAnalysis.direction
        };
        
        if (zoneAnalysis.direction === 'LONG') votes.LONG += 1.2; // Zone slightly higher weight
        else if (zoneAnalysis.direction === 'SHORT') votes.SHORT += 1.2;
        
        if (smcAnalysis.direction === 'LONG') votes.LONG += 1.2;
        else if (smcAnalysis.direction === 'SHORT') votes.SHORT += 1.2;
        
        if (momentumAnalysis.direction === 'LONG') votes.LONG += 1;
        else if (momentumAnalysis.direction === 'SHORT') votes.SHORT += 1;
        
        // Need at least 2 agreeing for a signal
        if (votes.LONG < 2 && votes.SHORT < 2) return null;
        
        const direction = votes.LONG > votes.SHORT ? 'LONG' : 'SHORT';
        
        // Count how many engines agree with final direction
        let agreed = 0;
        if (zoneAnalysis.direction === direction) agreed++;
        if (smcAnalysis.direction === direction) agreed++;
        if (momentumAnalysis.direction === direction) agreed++;
        
        // Get HTF bias
        const htfBias = await analyzeHTFBias(symbol, tf, direction);
        
        // Detect conflicts
        const conflictCheck = detectConflicts(zoneAnalysis, smcAnalysis, momentumAnalysis);
        
        // Calculate weighted score (OLD IDEA)
        const zoneWeighted = zoneAnalysis.score * CONFIG.WEIGHTS.zone;
        const smcWeighted = smcAnalysis.score * CONFIG.WEIGHTS.smc;
        const momentumWeighted = momentumAnalysis.score * CONFIG.WEIGHTS.momentum;
        
        let totalScore = zoneWeighted + smcWeighted + momentumWeighted;
        
        // Add HTF bonus
        totalScore += htfBias.score;
        
        // Apply conflict penalties
        totalScore += conflictCheck.penalty;
        
        // Ensure score is within bounds
        totalScore = Math.max(0, Math.min(100, Math.round(totalScore)));
        
        // Determine grade
        let grade, status;
        if (totalScore >= CONFIG.GRADES.PERFECT) {
            grade = 'PERFECT';
            status = 'ready';
        } else if (totalScore >= CONFIG.GRADES.STRONG) {
            grade = 'STRONG';
            status = 'ready';
        } else if (totalScore >= CONFIG.GRADES.VALID) {
            grade = 'VALID';
            status = 'ready';
        } else if (totalScore >= CONFIG.GRADES.HEATING) {
            grade = 'HEATING';
            status = 'early';
        } else {
            grade = 'BREWING';
            status = 'early';
        }
        
        // Calculate trade levels
        const adxVal = momentumAnalysis.details.adx ? momentumAnalysis.details.adx.adx : 25;
        const levels = calculateTradeLevels(currentPrice, direction, atr, zoneAnalysis.details, smcAnalysis.details, adxVal);
        
        // Combine all factors
        const allFactors = [
            ...zoneAnalysis.factors,
            ...smcAnalysis.factors,
            ...momentumAnalysis.factors
        ];
        
        const allWarnings = [
            ...zoneAnalysis.warnings,
            ...smcAnalysis.warnings,
            ...momentumAnalysis.warnings,
            ...conflictCheck.conflicts
        ];
        
        return {
            symbol,
            tf: CONFIG.TF_LABELS[tf] || tf,
            tfRaw: tf,
            price: currentPrice,
            direction,
            grade,
            status,
            score: totalScore,
            agreed,  // How many engines agreed (2 or 3)
            engineDirections,  // Individual engine directions
            scores: {
                zone: Math.round(zoneAnalysis.score),
                smc: Math.round(smcAnalysis.score),
                momentum: Math.round(momentumAnalysis.score),
                htf: htfBias.score
            },
            weighted: {
                zone: Math.round(zoneWeighted),
                smc: Math.round(smcWeighted),
                momentum: Math.round(momentumWeighted)
            },
            zone: zoneAnalysis,
            smc: smcAnalysis,
            momentum: momentumAnalysis,
            htf: htfBias,
            levels,
            factors: allFactors,
            warnings: allWarnings,
            conflicts: conflictCheck.conflicts,
            atr
        };
        
    } catch (error) {
        console.error(`Analysis error for ${symbol} ${tf}:`, error);
        return null;
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// MULTI-AI PROVIDER SYSTEM (v13 UPGRADE)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Call Groq AI
async function callGroqAI(prompt) {
    console.log('üöÄ Trying Groq AI...');
    const apiKey = getNextGroqKey();
    if (!apiKey) {
        console.log('‚ùå No Groq keys available');
        return null;
    }
    
    try {
        const response = await fetch(CONFIG.GROQ_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + apiKey
            },
            body: JSON.stringify({
                model: STATE.aiModel || 'llama-3.3-70b-versatile',
                messages: [{ role: 'user', content: prompt }],
                temperature: 0.3,
                max_tokens: 2000
            })
        });
        
        if (response.status === 429) {
            console.log('‚è≥ Groq rate limited');
            return null;
        }
        
        const data = await response.json();
        if (data.error) {
            console.warn('‚ùå Groq error:', data.error.message);
            return null;
        }
        
        if (data.choices && data.choices[0] && data.choices[0].message) {
            console.log('‚úÖ Groq response received');
            return parseAIResponse(data.choices[0].message.content);
        }
        return null;
    } catch (error) {
        console.error('‚ùå Groq request failed:', error);
        return null;
    }
}

// Call DeepSeek AI
async function callDeepSeekAI(prompt) {
    console.log('üöÄ Trying DeepSeek AI...');
    const apiKey = getNextDeepSeekKey();
    if (!apiKey) {
        console.log('‚ùå No DeepSeek keys available');
        return null;
    }
    
    try {
        const response = await fetch(CONFIG.DEEPSEEK_URL, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': 'Bearer ' + apiKey
            },
            body: JSON.stringify({
                model: 'deepseek-chat',
                messages: [{ role: 'user', content: prompt }],
                temperature: 0.3,
                max_tokens: 2000
            })
        });
        
        if (response.status === 429) {
            console.log('‚è≥ DeepSeek rate limited');
            return null;
        }
        
        const data = await response.json();
        if (data.error) {
            console.warn('‚ùå DeepSeek error:', data.error.message);
            return null;
        }
        
        if (data.choices && data.choices[0] && data.choices[0].message) {
            console.log('‚úÖ DeepSeek response received');
            return parseAIResponse(data.choices[0].message.content);
        }
        return null;
    } catch (error) {
        console.error('‚ùå DeepSeek request failed:', error);
        return null;
    }
}

// Call Gemini AI
async function callGeminiAI(prompt) {
    console.log('üöÄ Trying Gemini AI...');
    const apiKey = getNextGeminiKey();
    if (!apiKey) {
        console.log('‚ùå No Gemini keys available');
        return null;
    }
    
    try {
        const response = await fetch(CONFIG.GEMINI_URL + '?key=' + apiKey, {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json'
            },
            body: JSON.stringify({
                contents: [{ parts: [{ text: prompt }] }],
                generationConfig: {
                    temperature: 0.3,
                    maxOutputTokens: 2000
                }
            })
        });
        
        if (response.status === 429) {
            console.log('‚è≥ Gemini rate limited');
            return null;
        }
        
        const data = await response.json();
        if (data.error) {
            console.warn('‚ùå Gemini error:', data.error.message);
            return null;
        }
        
        if (data.candidates && data.candidates[0] && data.candidates[0].content) {
            console.log('‚úÖ Gemini response received');
            return parseAIResponse(data.candidates[0].content.parts[0].text);
        }
        return null;
    } catch (error) {
        console.error('‚ùå Gemini request failed:', error);
        return null;
    }
}

// Multi-AI with Auto-Failover (v13 Feature)
async function callMultiAI(prompt) {
    console.log('üß† Multi-AI System Starting...');
    
    // Try Groq first (free, fast)
    let result = await callGroqAI(prompt);
    if (result) {
        result.aiProvider = 'Groq';
        return result;
    }
    
    // Fallback to DeepSeek (paid, best value)
    result = await callDeepSeekAI(prompt);
    if (result) {
        result.aiProvider = 'DeepSeek';
        return result;
    }
    
    // Final fallback to Gemini (free backup)
    result = await callGeminiAI(prompt);
    if (result) {
        result.aiProvider = 'Gemini';
        return result;
    }
    
    console.error('‚ùå All AI providers failed');
    toast('All AI providers unavailable', 'error');
    return null;
}

// Legacy function for backwards compatibility
async function callAI(prompt) {
    return await callMultiAI(prompt);
}

function parseAIResponse(text) {
    console.log('üîÑ Parsing AI response...');
    try {
        // Clean up response
        let clean = text.replace(/```json/gi, '').replace(/```/g, '').trim();
        const match = clean.match(/\{[\s\S]*\}/);
        
        if (match) {
            console.log('üìã Found JSON in response');
            const parsed = JSON.parse(match[0]);
            console.log('‚úÖ JSON parsed successfully');
            console.log('üìä Parsed fields:', Object.keys(parsed).join(', '));
            
            return {
                // Core fields
                myDirection: parsed.myDirection || null,
                agreesWithScanner: parsed.agreesWithScanner !== undefined ? parsed.agreesWithScanner : true,
                confidence: Math.min(100, Math.max(0, parsed.confidence || 50)),
                verdict: ['TAKE', 'SKIP', 'WAIT'].includes(parsed.verdict) ? parsed.verdict : 'WAIT',
                
                // Summary (supports both old and new format)
                executiveSummary: parsed.executiveSummary || '',
                reasoning: parsed.reasoning || parsed.executiveSummary || 'Analysis complete',
                
                // Comprehensive analysis sections (new format - can be objects)
                marketContext: parsed.marketContext || '',
                smcAnalysis: parsed.smcAnalysis || null,
                smcAssessment: parsed.smcAssessment || '', // Legacy support
                momentumAnalysis: parsed.momentumAnalysis || null,
                zoneAnalysis: parsed.zoneAnalysis || null,
                tradeManagement: parsed.tradeManagement || null,
                riskAssessment: parsed.riskAssessment || null,
                leverageRecommendation: parsed.leverageRecommendation || null,
                actionPlan: parsed.actionPlan || null,
                professionalNotes: parsed.professionalNotes || '',
                
                // Legacy fields
                risks: Array.isArray(parsed.risks) ? parsed.risks : [],
                suggestions: Array.isArray(parsed.suggestions) ? parsed.suggestions : [],
                leverageAdvice: parsed.leverageAdvice || ''
            };
        } else {
            console.warn('‚ö†Ô∏è No JSON found in response');
            console.log('üìÑ Raw text:', text.substring(0, 500));
        }
    } catch (e) {
        console.error('‚ùå AI parse error:', e);
        console.log('üìÑ Failed text:', text.substring(0, 500));
    }
    
    return {
        myDirection: null,
        agreesWithScanner: true,
        confidence: 50,
        verdict: 'WAIT',
        reasoning: 'Could not parse AI response',
        executiveSummary: '',
        marketContext: '',
        smcAnalysis: null,
        smcAssessment: '',
        momentumAnalysis: null,
        zoneAnalysis: null,
        tradeManagement: null,
        riskAssessment: null,
        leverageRecommendation: null,
        actionPlan: null,
        professionalNotes: '',
        risks: [],
        suggestions: [],
        leverageAdvice: ''
    };
}

async function getAIAnalysis(signal) {
    if (!signal || !STATE.aiKey) return null;
    
    // Safe helper functions to prevent undefined errors
    const sf = (val, decimals = 2) => {
        if (val === undefined || val === null || isNaN(val)) return 'N/A';
        return Number(val).toFixed(decimals);
    };
    const ss = (val, fallback = 'N/A') => val !== undefined && val !== null ? val : fallback;
    
    // Safe object access
    const levels = signal.levels || {};
    const smc = signal.smc || {};
    const smcD = smc.details || {};
    const zone = signal.zone || {};
    const zoneD = zone.details || {};
    const mom = signal.momentum || {};
    const momD = mom.details || {};
    const htf = signal.htf || {};
    const scores = signal.scores || {};
    
    const prompt = `You are an ELITE institutional crypto trading analyst. Analyze this signal and provide your INDEPENDENT opinion.

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
SIGNAL DATA
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Asset: ${ss(signal.symbol)}
Timeframe: ${ss(signal.tf)}
Current Price: $${ss(signal.price)}
Scanner Direction: ${ss(signal.direction)}
Grade: ${ss(signal.grade)} (${ss(signal.score, 0)}/100)
Scores: Zone ${ss(scores.zone, 0)} | SMC ${ss(scores.smc, 0)} | Momentum ${ss(scores.momentum, 0)}
Warnings: ${signal.warnings?.length > 0 ? signal.warnings.join(', ') : 'None'}
Key Factors: ${signal.factors?.slice(0, 6).join(', ') || 'None'}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
SMC DATA
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Structure: ${smcD.structure ? ss(smcD.structure.trend) : 'N/A'}
Trigger: ${ss(smc.trigger, 'None')}
P/D Zone: ${smcD.pdZone ? ss(smcD.pdZone.zone) + ' (' + sf(smcD.pdZone.positionPct, 1) + '%)' : 'N/A'}
Order Blocks: ${smcD.orderBlocks ? 'Bull: ' + (smcD.orderBlocks.bullish?.length || 0) + ' Bear: ' + (smcD.orderBlocks.bearish?.length || 0) : 'N/A'}
FVGs: ${smcD.fvg ? 'Bull: ' + (smcD.fvg.bullish?.length || 0) + ' Bear: ' + (smcD.fvg.bearish?.length || 0) : 'N/A'}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
ZONE DATA
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Support: ${zoneD.nearestSupport ? '$' + sf(zoneD.nearestSupport.price, 4) + ' (Str: ' + ss(zoneD.nearestSupport.strength) + ')' : 'N/A'}
Resistance: ${zoneD.nearestResistance ? '$' + sf(zoneD.nearestResistance.price, 4) + ' (Str: ' + ss(zoneD.nearestResistance.strength) + ')' : 'N/A'}
Status: ${ss(zone.status)}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
MOMENTUM DATA
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
RSI: ${momD.rsi ? sf(momD.rsi.value, 1) + ' (' + ss(momD.rsi.trend) + ')' : 'N/A'}
MACD: ${momD.macd ? ss(momD.macd.trend) + (momD.macd.crossover ? ' ' + momD.macd.crossover : '') : 'N/A'}
ADX: ${momD.adx && momD.adx.adx !== undefined ? sf(momD.adx.adx, 1) + ' (' + ss(momD.adx.strength) + ')' : 'N/A'}
StochRSI: ${momD.stochRSI ? 'K:' + sf(momD.stochRSI.k, 1) + ' D:' + sf(momD.stochRSI.d, 1) : 'N/A'}
Volume: ${momD.volume ? ss(momD.volume.trend) + ' (' + sf(momD.volume.ratio, 1) + 'x)' : 'N/A'}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
HTF BIAS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
${htf.bias ? Object.entries(htf.bias).map(([t, b]) => t + ':' + b).join(' | ') : 'N/A'}
Aligned: ${ss(htf.aligned, 0)}/${ss(htf.total, 0)}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
TRADE LEVELS
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Entry: $${sf(levels.entry, 4)}
SL: $${sf(levels.sl, 4)} (${ss(levels.riskPct)}%)
TP1: $${sf(levels.tp1, 4)} | TP2: $${sf(levels.tp2, 4)} | TP3: $${sf(levels.tp3, 4)}
R:R = 1:${ss(levels.rr)}

‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
YOUR TASK
‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
Analyze as an institutional trader. Give your INDEPENDENT verdict.

Respond ONLY with this JSON:
{
  "myDirection": "LONG" or "SHORT" or "NO_TRADE",
  "agreesWithScanner": true or false,
  "confidence": 0-100,
  "verdict": "TAKE" or "SKIP" or "WAIT",
  "executiveSummary": "2-3 sentences on the trade opportunity",
  "smcAnalysis": {
    "structureValidity": "your assessment",
    "orderBlockQuality": "Fresh/Mitigated/Weak",
    "institutionalBias": "what smart money is doing"
  },
  "momentumAnalysis": {
    "trendStrength": "Weak/Moderate/Strong",
    "entryTiming": "Optimal/Suboptimal"
  },
  "riskAssessment": {
    "primaryRisks": ["risk1", "risk2"],
    "invalidationLevel": "price that invalidates"
  },
  "leverageRecommendation": {
    "suggested": "1x-10x",
    "reasoning": "why"
  },
  "actionPlan": {
    "immediateAction": "what to do now",
    "conditions": "conditions to meet"
  },
  "professionalNotes": "additional insights"
}`;

    return await callMultiAI(prompt);
}
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SCANNER ENGINE
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async function runScanner() {
    if (!STATE.scanning) return;
    
    // Store previous signals for comparison (for status badges)
    STATE.previousSignals = [...STATE.signals];
    
    const signals = [];
    const coins = CONFIG.COINS.length > 0 ? CONFIG.COINS : CONFIG.ALL_COINS.slice(0, STATE.coinCount);
    let timeframes;
    
    if (STATE.mode === 'SCALP') {
        timeframes = CONFIG.TF_SCALP;
    } else if (STATE.mode === 'SWING') {
        timeframes = CONFIG.TF_SWING;
    } else {
        timeframes = CONFIG.TF_ALL;
    }
    
    // Filter by enabled timeframes from settings
    timeframes = timeframes.filter(tf => STATE.tfEnabled[tf]);
    
    if (timeframes.length === 0) {
        toast('No timeframes enabled! Enable at least one in Settings.', 'error');
        STATE.scanning = false;
        document.getElementById('scanBtn').className = 'btn';
        document.getElementById('scanIcon').textContent = '‚óè';
        return;
    }
    
    const total = coins.length * timeframes.length;
    let current = 0;
    
    // Track previous signal count for alerts
    const prevSignalCount = STATE.signals.length;
    
    STATE.scanProgress = { current: 0, total, coin: '', tf: '' };
    
    for (const coin of coins) {
        if (!STATE.scanning) break;
        
        for (const tf of timeframes) {
            if (!STATE.scanning) break;
            
            current++;
            STATE.scanProgress = {
                current,
                total,
                coin: coin.replace('USDT', ''),
                tf: CONFIG.TF_LABELS[tf] || tf
            };
            
            updateScanStatus();
            
            try {
                const signal = await analyzeSignal(coin, tf);
                if (signal) {
                    signals.push(signal);
                }
            } catch (e) {
                console.error(`Scan error ${coin} ${tf}:`, e);
            }
            
            await sleep(CONFIG.SCAN_DELAY);
        }
    }
    
    // Sort by score descending
    signals.sort((a, b) => b.score - a.score);
    
    // Check for new high-grade signals and trigger alert
    const gradeOrder = ['PERFECT', 'STRONG', 'VALID', 'HEATING', 'BREWING'];
    const alertGradeIdx = gradeOrder.indexOf(STATE.alertGrade);
    
    const newHighGradeSignals = signals.filter(sig => {
        const sigGradeIdx = gradeOrder.indexOf(sig.grade);
        return sigGradeIdx <= alertGradeIdx && sigGradeIdx >= 0;
    });
    
    // Trigger alert if we have new qualifying signals
    if (newHighGradeSignals.length > 0 && signals.length > prevSignalCount) {
        triggerAlert(newHighGradeSignals[0]);
    }
    
    STATE.signals = signals;
    STATE.selected = null;
    STATE.current = null;
    STATE.aiResult = null;
    
    updateSignalList();
    updateCounts();
    updateMainPanel();
    
    toast(`Scan complete: ${signals.length} signals found`, 'success');
    
    // Set progress bar to green (complete)
    setScanComplete();
    
    // Auto-rescan using configured interval
    if (STATE.scanning) {
        // Reset progress bar before next scan
        setTimeout(() => {
            resetScanProgress();
            runScanner();
        }, STATE.scanInterval);
    }
}

function updateScanStatus() {
    const el = document.getElementById('signalList');
    if (!el) return;
    
    const p = STATE.scanProgress;
    const pct = p.total > 0 ? Math.round((p.current / p.total) * 100) : 0;
    
    // Update progress bar (background scan - don't hide signals!)
    const progressBar = document.getElementById('scanProgressBar');
    const progressFill = document.getElementById('scanProgressFill');
    const progressText = document.getElementById('scanProgressText');
    const progressPct = document.getElementById('scanProgressPct');
    
    if (progressBar && STATE.scanning && p.total > 0) {
        progressBar.classList.add('active');
        if (progressFill) progressFill.style.width = pct + '%';
        if (progressText) progressText.textContent = `üîÑ ${p.coin} ${p.tf}`;
        if (progressPct) progressPct.textContent = `${p.current}/${p.total}`;
    } else if (progressBar) {
        progressBar.classList.remove('active');
    }
    
    // Only show loading if NO signals yet (first scan)
    if (STATE.signals.length === 0 && el) {
        el.innerHTML = `
            <div class="empty">
                <div class="spinner"></div>
                <div style="font-size:14px;font-weight:600">${p.coin} ${p.tf}</div>
                <div class="scan-status">${p.current}/${p.total} (${pct}%)</div>
            </div>
        `;
    }
    // Otherwise, signals stay visible during rescan!
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// UI RENDERING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function updateSignalList() {
    const el = document.getElementById('signalList');
    let filtered = [...STATE.signals];
    
    // Apply mode filter
    if (STATE.mode === 'SCALP') {
        filtered = filtered.filter(s => ['5m', '15m', '30m', '1H'].includes(s.tf));
    } else if (STATE.mode === 'SWING') {
        filtered = filtered.filter(s => ['1H', '4H', '1D'].includes(s.tf));
    }
    
    // Apply status filter
    if (STATE.filter === 'perfect') {
        filtered = filtered.filter(s => s.grade === 'PERFECT');
    } else if (STATE.filter === 'ready') {
        filtered = filtered.filter(s => s.status === 'ready');
    } else if (STATE.filter === 'early') {
        filtered = filtered.filter(s => s.status === 'early');
    }
    
    // Apply stats bar filter
    if (STATE.statsFilter === 'perfect') {
        filtered = filtered.filter(s => s.grade === 'PERFECT');
    } else if (STATE.statsFilter === 'long') {
        filtered = filtered.filter(s => s.direction === 'LONG');
    } else if (STATE.statsFilter === 'short') {
        filtered = filtered.filter(s => s.direction === 'SHORT');
    } else if (STATE.statsFilter === 'agree3') {
        filtered = filtered.filter(s => s.agreed === 3);
    }
    
    if (filtered.length === 0) {
        el.innerHTML = `
            <div class="empty">
                <div class="empty-icon glow-radar">üì°</div>
                <div>${STATE.scanning ? 'Scanning...' : 'No signals found'}</div>
            </div>
        `;
        return;
    }
    
    el.innerHTML = filtered.map((sig, idx) => {
        const realIdx = STATE.signals.indexOf(sig);
        const isActive = STATE.selected === realIdx;
        const isScalp = ['5m', '15m', '30m', '1H'].includes(sig.tf);
        const htfOk = sig.htf && sig.htf.aligned >= 2;
        const agreementColor = sig.agreed === 3 ? 'var(--long)' : 'var(--amber)';
        const fullAgreeClass = sig.agreed === 3 ? 'full-agree' : '';
        const gradeClass = 'grade-' + sig.grade.toLowerCase();
        
        // Calculate status badge (compare with previous scan)
        let statusBadge = '';
        const sigKey = sig.symbol + '_' + sig.tf;
        const prevSig = STATE.previousSignals.find(p => p.symbol === sig.symbol && p.tf === sig.tf);
        
        if (!prevSig) {
            statusBadge = '<span class="status-badge new">üÜï NEW</span>';
        } else {
            const scoreDiff = sig.score - prevSig.score;
            if (scoreDiff >= 5) {
                statusBadge = `<span class="status-badge up">‚¨ÜÔ∏è+${scoreDiff}</span>`;
            } else if (scoreDiff <= -5) {
                statusBadge = `<span class="status-badge down">‚¨áÔ∏è${scoreDiff}</span>`;
            }
        }
        
        return `
            <div class="signal-card ${sig.direction.toLowerCase()} ${gradeClass} ${fullAgreeClass} ${isActive ? 'active' : ''}" 
                 onclick="selectSignal(${realIdx})">
                <div class="signal-top">
                    <div class="signal-pair">
                        ${sig.symbol.replace('USDT', '')}
                        <span class="dir-tag ${sig.direction.toLowerCase()}">${sig.direction}</span>
                        <span class="tf-tag">${sig.tf}</span>
                        <span style="font-size:11px;color:${agreementColor};font-weight:700">${sig.agreed}/3</span>
                        ${htfOk ? '<span style="font-size:11px;color:var(--cyan)">HTF‚úì</span>' : ''}
                        ${statusBadge}
                    </div>
                    <span class="grade ${sig.grade.toLowerCase()}">${sig.grade}</span>
                </div>
                <div class="signal-meta">
                    <span>üìä ${sig.score}</span>
                    <span>üí∞ $${fmtPrice(sig.price)}</span>
                    <span>R:R 1:${sig.levels.rr}</span>
                </div>
                <div class="signal-scores">
                    <span class="score-tag ${scoreClass(sig.scores.zone)}" title="Zone: ${sig.engineDirections.zone || 'N/A'}">Z:${sig.scores.zone}${sig.engineDirections.zone === sig.direction ? '‚úì' : ''}</span>
                    <span class="score-tag ${scoreClass(sig.scores.smc)}" title="SMC: ${sig.engineDirections.smc || 'N/A'}">S:${sig.scores.smc}${sig.engineDirections.smc === sig.direction ? '‚úì' : ''}</span>
                    <span class="score-tag ${scoreClass(sig.scores.momentum)}" title="Momentum: ${sig.engineDirections.momentum || 'N/A'}">M:${sig.scores.momentum}${sig.engineDirections.momentum === sig.direction ? '‚úì' : ''}</span>
                    <span class="score-tag" style="color:var(--cyan)">H:${sig.scores.htf}</span>
                </div>
            </div>
        `;
    }).join('');
}

function updateCounts() {
    let filtered = [...STATE.signals];
    
    if (STATE.mode === 'SCALP') {
        filtered = filtered.filter(s => ['5m', '15m', '30m', '1H'].includes(s.tf));
    } else if (STATE.mode === 'SWING') {
        filtered = filtered.filter(s => ['1H', '4H', '1D'].includes(s.tf));
    }
    
    // Update filter counts
    document.getElementById('cAll').textContent = filtered.length;
    document.getElementById('cPerfect').textContent = filtered.filter(s => s.grade === 'PERFECT').length;
    document.getElementById('cReady').textContent = filtered.filter(s => s.status === 'ready').length;
    document.getElementById('cEarly').textContent = filtered.filter(s => s.status === 'early').length;
    
    // Update dashboard stats bar
    document.getElementById('statTotal').textContent = filtered.length;
    document.getElementById('statPerfect').textContent = filtered.filter(s => s.grade === 'PERFECT').length;
    document.getElementById('statLong').textContent = filtered.filter(s => s.direction === 'LONG').length;
    document.getElementById('statShort').textContent = filtered.filter(s => s.direction === 'SHORT').length;
    document.getElementById('statFullAgree').textContent = filtered.filter(s => s.agreed === 3).length;
}

function updateMainPanel() {
    const el = document.getElementById('mainPanel');
    
    if (!STATE.current) {
        el.innerHTML = `
            <div class="empty">
                <div class="empty-icon">üëà</div>
                <div>Select a signal to view details</div>
            </div>
        `;
        return;
    }
    
    const sig = STATE.current;
    const ai = STATE.aiResult;
    
    // HTF Box
    const htfHtml = `
        <div class="htf-box">
            <div class="htf-title">üìà HTF Bias (${sig.htf.aligned}/${sig.htf.total} Aligned)</div>
            <div class="htf-grid">
                ${Object.entries(sig.htf.bias).map(([tf, bias]) => `
                    <div class="htf-item">
                        <div class="htf-label">${tf}</div>
                        <div class="htf-value ${bias === 'BULLISH' ? 'bull' : bias === 'BEARISH' ? 'bear' : 'neutral'}">${bias}</div>
                    </div>
                `).join('')}
            </div>
        </div>
    `;
    
    // AI Section - Expandable with Comprehensive Independent Analysis
    let aiHtml;
    if (ai) {
        const verdictClass = ai.verdict === 'TAKE' ? 'take' : ai.verdict === 'SKIP' ? 'skip' : 'wait';
        const barColor = ai.verdict === 'TAKE' ? 'var(--long)' : ai.verdict === 'SKIP' ? 'var(--short)' : 'var(--amber)';
        const agreementColor = ai.agreesWithScanner ? 'var(--long)' : 'var(--short)';
        const agreementText = ai.agreesWithScanner ? '‚úì AGREES' : '‚úó DISAGREES';
        const aiDirectionColor = ai.myDirection === 'LONG' ? 'var(--long)' : ai.myDirection === 'SHORT' ? 'var(--short)' : 'var(--text3)';
        
        // Helper to format nested objects safely
        const formatObj = (obj, color) => {
            if (!obj) return '';
            if (typeof obj === 'string') return '<div style="font-size:12px;color:var(--text2)">' + obj + '</div>';
            return '<div style="font-size:12px;color:var(--text2)">' + 
                Object.entries(obj).filter(([k,v]) => v && v !== 'N/A').map(([k,v]) => {
                    const label = k.replace(/([A-Z])/g, ' $1').replace(/^./, s => s.toUpperCase());
                    if (Array.isArray(v)) return '<div style="margin-bottom:4px"><b>' + label + ':</b> ' + v.join(', ') + '</div>';
                    return '<div style="margin-bottom:4px"><b>' + label + ':</b> ' + v + '</div>';
                }).join('') + '</div>';
        };
        
        // Get risks array (handles both old and new format)
        const getRisks = () => {
            if (ai.riskAssessment && ai.riskAssessment.primaryRisks && ai.riskAssessment.primaryRisks.length) return ai.riskAssessment.primaryRisks;
            if (ai.risks && ai.risks.length) return ai.risks;
            return [];
        };
        
        // Get summary (handles both formats)
        const getSummary = () => ai.executiveSummary || ai.reasoning || '';
        
        // Get leverage info
        const getLeverage = () => ai.leverageRecommendation || ai.leverageAdvice || null;
        
        aiHtml = `
            <div class="ai-section">
                <div class="ai-header" onclick="toggleAIExpand()" style="cursor:pointer">
                    <span class="ai-title">ü§ñ AI Institutional Analysis</span>
                    <div style="display:flex;align-items:center;gap:8px">
                        <span class="ai-verdict ${verdictClass}">${ai.verdict}</span>
                        <span style="font-size:14px">${STATE.aiExpanded ? '‚ñº' : '‚ñ∂'}</span>
                    </div>
                </div>
                
                <div class="ai-bar"><div class="ai-fill" style="width:${ai.confidence}%;background:${barColor}"></div></div>
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                    <span style="font-size:12px">Confidence: <b>${ai.confidence}%</b></span>
                    <span style="font-size:11px;color:${agreementColor};font-weight:700">${agreementText} with Scanner</span>
                </div>
                
                <div style="display:flex;gap:8px;margin-bottom:10px">
                    <div style="flex:1;text-align:center;padding:8px;background:var(--bg4);border-radius:6px">
                        <div style="font-size:11px;color:var(--text3)">Scanner Says</div>
                        <div style="font-size:14px;font-weight:700;color:${sig.direction === 'LONG' ? 'var(--long)' : 'var(--short)'}">${sig.direction}</div>
                    </div>
                    <div style="flex:1;text-align:center;padding:8px;background:var(--bg4);border-radius:6px;border:1px solid ${aiDirectionColor}">
                        <div style="font-size:11px;color:var(--text3)">AI Says</div>
                        <div style="font-size:14px;font-weight:700;color:${aiDirectionColor}">${ai.myDirection || 'N/A'}</div>
                    </div>
                </div>
                
                <div class="ai-text" style="background:var(--bg4);padding:10px;border-radius:6px;border-left:3px solid ${barColor}">${getSummary()}</div>
                
                <div id="aiExpandedContent" style="display:${STATE.aiExpanded ? 'block' : 'none'};margin-top:12px;border-top:1px solid var(--border);padding-top:12px">
                    
                    ${ai.marketContext ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px"><div style="font-size:11px;color:var(--cyan);font-weight:700;margin-bottom:6px">üìä MARKET CONTEXT</div>' + formatObj(ai.marketContext, 'cyan') + '</div>' : ''}
                    
                    ${(ai.smcAnalysis || ai.smcAssessment) ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px"><div style="font-size:11px;color:var(--purple);font-weight:700;margin-bottom:6px">üéØ SMC ANALYSIS</div>' + formatObj(ai.smcAnalysis || ai.smcAssessment, 'purple') + '</div>' : ''}
                    
                    ${ai.momentumAnalysis ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px"><div style="font-size:11px;color:var(--blue);font-weight:700;margin-bottom:6px">‚ö° MOMENTUM</div>' + formatObj(ai.momentumAnalysis, 'blue') + '</div>' : ''}
                    
                    ${ai.zoneAnalysis ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px"><div style="font-size:11px;color:var(--gold);font-weight:700;margin-bottom:6px">üìç ZONES</div>' + formatObj(ai.zoneAnalysis, 'gold') + '</div>' : ''}
                    
                    ${ai.tradeManagement ? '<div style="margin-bottom:12px;background:var(--bg4);padding:10px;border-radius:6px"><div style="font-size:11px;color:var(--long);font-weight:700;margin-bottom:6px">üìà TRADE MANAGEMENT</div>' + formatObj(ai.tradeManagement, 'long') + '</div>' : ''}
                    
                    ${(ai.riskAssessment || getRisks().length > 0) ? '<div style="margin-bottom:12px;background:var(--short-dim);padding:10px;border-radius:6px;border:1px solid var(--short)"><div style="font-size:11px;color:var(--short);font-weight:700;margin-bottom:6px">‚ö†Ô∏è RISKS</div>' + (ai.riskAssessment ? formatObj(ai.riskAssessment, 'short') : '<div style="font-size:12px;color:var(--text2)">' + getRisks().map(r => '‚Ä¢ ' + r).join('<br>') + '</div>') + '</div>' : ''}
                    
                    ${getLeverage() ? '<div style="margin-bottom:12px;background:var(--amber-dim);border:1px solid var(--amber);border-radius:6px;padding:10px"><div style="font-size:11px;color:var(--amber);font-weight:700;margin-bottom:6px">‚ö° LEVERAGE</div>' + formatObj(getLeverage(), 'amber') + '</div>' : ''}
                    
                    ${ai.actionPlan ? '<div style="margin-bottom:12px;background:linear-gradient(135deg,var(--long-dim),var(--cyan-dim));padding:10px;border-radius:6px;border:1px solid var(--long)"><div style="font-size:11px;color:var(--long);font-weight:700;margin-bottom:6px">üéØ ACTION PLAN</div>' + formatObj(ai.actionPlan, 'long') + '</div>' : ''}
                    
                    ${ai.professionalNotes ? '<div style="background:var(--bg4);padding:10px;border-radius:6px;border-left:3px solid var(--purple)"><div style="font-size:11px;color:var(--purple);font-weight:700;margin-bottom:6px">üìù PRO NOTES</div><div style="font-size:12px;color:var(--text2);font-style:italic">' + ai.professionalNotes + '</div></div>' : ''}
                    
                    ${(ai.suggestions && ai.suggestions.length > 0 && !ai.actionPlan) ? '<div style="margin-bottom:10px"><div style="font-size:11px;color:var(--long);font-weight:700;margin-bottom:4px">üí° Suggestions</div><div style="font-size:12px;color:var(--text2)">' + ai.suggestions.map(s => '‚Ä¢ ' + s).join('<br>') + '</div></div>' : ''}
                </div>
                
                <div style="display:flex;gap:8px;margin-top:10px">
                    <button class="btn" onclick="toggleAIExpand()" style="flex:1">${STATE.aiExpanded ? '‚ñ≤ Collapse' : '‚ñº Expand Details'}</button>
                    <button class="btn" onclick="askAI()" style="flex:1">üîÑ Refresh AI</button>
                </div>
            </div>
        `;
    } else {
        aiHtml = `
            <div class="ai-section" style="text-align:center;padding:20px">
                <div style="font-size:32px;margin-bottom:8px">üß†</div>
                <div style="font-size:13px;font-weight:600;margin-bottom:4px">Independent AI Analysis</div>
                <div style="font-size:12px;color:var(--text2);margin-bottom:12px">AI will analyze raw data and give its own opinion</div>
                <button class="ai-btn" onclick="askAI()">üß† Ask Multi-AI</button>
            </div>
        `;
    }
    
    // Analysis Grid
    const analysisHtml = `
        <div class="analysis-grid">
            <div class="analysis-card">
                <div class="analysis-head">
                    <span class="analysis-title">üìç Zone Analysis</span>
                    <span class="analysis-score" style="background:${scoreColor(sig.scores.zone)}20;color:${scoreColor(sig.scores.zone)}">${sig.scores.zone}</span>
                </div>
                ${sig.zone.details.nearestSupport ? `
                    <div class="analysis-row">
                        <span class="analysis-label">Support</span>
                        <span class="analysis-value">$${fmtPrice(sig.zone.details.nearestSupport.price)}</span>
                    </div>
                ` : ''}
                ${sig.zone.details.nearestResistance ? `
                    <div class="analysis-row">
                        <span class="analysis-label">Resistance</span>
                        <span class="analysis-value">$${fmtPrice(sig.zone.details.nearestResistance.price)}</span>
                    </div>
                ` : ''}
                <div class="analysis-row">
                    <span class="analysis-label">Status</span>
                    <span class="analysis-value">${sig.zone.status}</span>
                </div>
                <div class="factor-list">
                    ${sig.zone.factors.map(f => `<span class="factor ${getFactorClass(f)}">${f}</span>`).join('')}
                </div>
            </div>
            
            <div class="analysis-card">
                <div class="analysis-head">
                    <span class="analysis-title">üéØ SMC Analysis</span>
                    <span class="analysis-score" style="background:${scoreColor(sig.scores.smc)}20;color:${scoreColor(sig.scores.smc)}">${sig.scores.smc}</span>
                </div>
                <div class="analysis-row">
                    <span class="analysis-label">Structure</span>
                    <span class="analysis-value">${sig.smc.details.trend || 'N/A'}</span>
                </div>
                <div class="analysis-row">
                    <span class="analysis-label">P/D Zone</span>
                    <span class="analysis-value">${sig.smc.details.pdZone ? sig.smc.details.pdZone.zone : 'N/A'}</span>
                </div>
                ${sig.smc.trigger ? `
                    <div class="analysis-row">
                        <span class="analysis-label">Trigger</span>
                        <span class="analysis-value" style="color:var(--gold)">${sig.smc.trigger}</span>
                    </div>
                ` : ''}
                <div class="factor-list">
                    ${sig.smc.factors.map(f => `<span class="factor ${getFactorClass(f)}">${f}</span>`).join('')}
                </div>
            </div>
            
            <div class="analysis-card">
                <div class="analysis-head">
                    <span class="analysis-title">üìà Momentum</span>
                    <span class="analysis-score" style="background:${scoreColor(sig.scores.momentum)}20;color:${scoreColor(sig.scores.momentum)}">${sig.scores.momentum}</span>
                </div>
                <div class="analysis-row">
                    <span class="analysis-label">RSI</span>
                    <span class="analysis-value">${sig.momentum.details.rsi ? sig.momentum.details.rsi.value.toFixed(1) : 'N/A'}</span>
                </div>
                <div class="analysis-row">
                    <span class="analysis-label">ADX</span>
                    <span class="analysis-value">${sig.momentum.details.adx ? sig.momentum.details.adx.adx.toFixed(1) : 'N/A'}</span>
                </div>
                <div class="analysis-row">
                    <span class="analysis-label">MACD</span>
                    <span class="analysis-value">${sig.momentum.details.macd ? sig.momentum.details.macd.trend : 'N/A'}</span>
                </div>
                <div class="factor-list">
                    ${sig.momentum.factors.map(f => `<span class="factor ${getFactorClass(f)}">${f}</span>`).join('')}
                </div>
            </div>
        </div>
    `;
    
    // Warnings
    const warningsHtml = sig.warnings.length > 0 ? `
        <div style="background:var(--amber-dim);border:1px solid var(--amber);border-radius:6px;padding:10px;margin-bottom:12px">
            <div style="font-size:11px;color:var(--amber);font-weight:600;margin-bottom:4px">‚ö†Ô∏è Warnings</div>
            <div style="font-size:12px;color:var(--amber)">${sig.warnings.join(' ‚Ä¢ ')}</div>
        </div>
    ` : '';
    
    // Trade Levels
    const tradeHtml = `
        <div class="trade-section">
            <div class="trade-title">üìä Trade Levels</div>
            <div class="trade-grid">
                <div class="trade-box entry">
                    <div class="trade-box-label">MARKET</div>
                    <div class="trade-box-value">$${fmtPrice(sig.levels.entry)}</div>
                </div>
                <div class="trade-box limit">
                    <div class="trade-box-label">LIMIT</div>
                    <div class="trade-box-value">$${fmtPrice(sig.levels.limitEntry)}</div>
                    <div class="limit-type">(${sig.levels.limitType})</div>
                </div>
                <div class="trade-box sl">
                    <div class="trade-box-label">STOP LOSS</div>
                    <div class="trade-box-value">$${fmtPrice(sig.levels.sl)}</div>
                </div>
                <div class="trade-box tp">
                    <div class="trade-box-label">TP1 (1.5R)</div>
                    <div class="trade-box-value">$${fmtPrice(sig.levels.tp1)}</div>
                </div>
                <div class="trade-box tp">
                    <div class="trade-box-label">TP2 (2.5R)</div>
                    <div class="trade-box-value">$${fmtPrice(sig.levels.tp2)}</div>
                </div>
            </div>
            <div class="trade-meta">
                <span class="rr-tag">Market R:R 1:${sig.levels.rr} | Limit R:R 1:${sig.levels.limitRR}</span>
                <button class="track-btn" onclick="trackTrade()">üìå Track Trade</button>
            </div>
        </div>
    `;
    
    // Agreement Box
    const zoneAgree = sig.engineDirections.zone === sig.direction;
    const smcAgree = sig.engineDirections.smc === sig.direction;
    const momAgree = sig.engineDirections.momentum === sig.direction;
    // Use direction-appropriate color: GREEN for LONG, RED for SHORT
    const dirColor = sig.direction === 'LONG' ? 'var(--long)' : 'var(--short)';
    const agreementColor = sig.agreed === 3 ? dirColor : 'var(--amber)';
    
    const agreementHtml = `
        <div style="background:var(--bg4);border-radius:6px;padding:10px;margin-bottom:12px">
            <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:8px">
                <span style="font-size:11px;color:var(--text2)">üéØ Engine Agreement</span>
                <span style="font-size:14px;font-weight:700;color:${agreementColor}">${sig.agreed}/3 Agree</span>
            </div>
            <div style="display:grid;grid-template-columns:repeat(3,1fr);gap:6px">
                <div style="text-align:center;padding:8px;background:var(--bg3);border-radius:4px;border:1px solid ${zoneAgree ? dirColor : 'var(--border)'}">
                    <div style="font-size:11px;color:var(--text3)">ZONE</div>
                    <div style="font-size:12px;font-weight:700;color:${zoneAgree ? dirColor : 'var(--text3)'}">${sig.engineDirections.zone || 'N/A'}</div>
                    <div style="font-size:11px;color:${zoneAgree ? dirColor : 'var(--text3)'}">${zoneAgree ? '‚úì Agrees' : '‚úó Differs'}</div>
                </div>
                <div style="text-align:center;padding:8px;background:var(--bg3);border-radius:4px;border:1px solid ${smcAgree ? dirColor : 'var(--border)'}">
                    <div style="font-size:11px;color:var(--text3)">SMC</div>
                    <div style="font-size:12px;font-weight:700;color:${smcAgree ? dirColor : 'var(--text3)'}">${sig.engineDirections.smc || 'N/A'}</div>
                    <div style="font-size:11px;color:${smcAgree ? dirColor : 'var(--text3)'}">${smcAgree ? '‚úì Agrees' : '‚úó Differs'}</div>
                </div>
                <div style="text-align:center;padding:8px;background:var(--bg3);border-radius:4px;border:1px solid ${momAgree ? dirColor : 'var(--border)'}">
                    <div style="font-size:11px;color:var(--text3)">MOMENTUM</div>
                    <div style="font-size:12px;font-weight:700;color:${momAgree ? dirColor : 'var(--text3)'}">${sig.engineDirections.momentum || 'N/A'}</div>
                    <div style="font-size:11px;color:${momAgree ? dirColor : 'var(--text3)'}">${momAgree ? '‚úì Agrees' : '‚úó Differs'}</div>
                </div>
            </div>
        </div>
    `;
    
    el.innerHTML = `
        <div class="detail-box">
            <div class="detail-header">
                <div class="detail-title">
                    <span class="detail-pair">${sig.symbol.replace('USDT', '')}</span>
                    <span class="dir-tag ${sig.direction.toLowerCase()}" style="font-size:12px;padding:4px 10px">${sig.direction}</span>
                    <span class="grade ${sig.grade.toLowerCase()}" style="font-size:11px;padding:4px 10px">${sig.grade}</span>
                    <span class="tf-tag" style="font-size:12px">${sig.tf}</span>
                </div>
                <div class="detail-price">
                    <div class="detail-price-label">Current Price</div>
                    <div class="detail-price-value">$${fmtPrice(sig.price)}</div>
                </div>
            </div>
            ${agreementHtml}
            ${htfHtml}
            ${aiHtml}
            ${warningsHtml}
            ${analysisHtml}
            ${tradeHtml}
        </div>
    `;
}

function getFactorClass(factor) {
    const bullish = ['‚Üë', 'Bull', 'Support', 'Discount', 'OS', 'MACD+', 'OBV+', 'Golden', '+'];
    const bearish = ['‚Üì', 'Bear', 'Resist', 'Premium', 'OB', 'MACD-', 'OBV-', 'Death', '-'];
    
    for (const b of bullish) {
        if (factor.includes(b)) return 'bull';
    }
    for (const s of bearish) {
        if (factor.includes(s)) return 'bear';
    }
    return '';
}


// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TRADE TRACKING
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function trackTrade() {
    if (!STATE.current) {
        toast('No signal selected!', 'error');
        return;
    }
    
    const sig = STATE.current;
    
    // Check if already tracking
    const exists = STATE.trades.find(t => t.symbol === sig.symbol && t.tf === sig.tf);
    if (exists) {
        toast('Already tracking this trade!', 'warning');
        return;
    }
    
    const trade = {
        id: Date.now(),
        symbol: sig.symbol,
        tf: sig.tf,
        direction: sig.direction,
        grade: sig.grade,
        entry: sig.levels.entry,
        sl: sig.levels.sl,
        tp1: sig.levels.tp1,
        tp2: sig.levels.tp2,
        tp3: sig.levels.tp3,
        rr: sig.levels.rr,
        currentPrice: sig.price,
        tp1Hit: false,
        tp2Hit: false,
        tp3Hit: false,
        slHit: false,
        timestamp: new Date().toISOString()
    };
    
    STATE.trades.push(trade);
    saveTrades();
    updateTradeList();
    
    toast(`üìå Tracking ${sig.symbol.replace('USDT', '')} ${sig.direction}!`, 'success');
}

function closeTrade(id) {
    STATE.trades = STATE.trades.filter(t => t.id !== id);
    saveTrades();
    updateTradeList();
    toast('Trade closed', 'success');
}

function saveTrades() {
    try {
        localStorage.setItem('bybit_scanner_trades', JSON.stringify(STATE.trades));
    } catch (e) {
        console.error('Failed to save trades:', e);
    }
}

function loadTrades() {
    try {
        const saved = localStorage.getItem('bybit_scanner_trades');
        if (saved) {
            STATE.trades = JSON.parse(saved);
        }
    } catch (e) {
        console.error('Failed to load trades:', e);
        STATE.trades = [];
    }
}

async function updateTradePrices() {
    for (const trade of STATE.trades) {
        try {
            const url = `${CONFIG.BYBIT_BASE}/v5/market/tickers?category=linear&symbol=${trade.symbol}`;
            const data = await fetchJSON(url);
            
            if (data && data.result && data.result.list && data.result.list[0]) {
                trade.currentPrice = parseFloat(data.result.list[0].lastPrice);
                
                // Check TP/SL hits
                if (trade.direction === 'LONG') {
                    if (trade.currentPrice >= trade.tp1) trade.tp1Hit = true;
                    if (trade.currentPrice >= trade.tp2) trade.tp2Hit = true;
                    if (trade.currentPrice >= trade.tp3) trade.tp3Hit = true;
                    if (trade.currentPrice <= trade.sl) trade.slHit = true;
                } else {
                    if (trade.currentPrice <= trade.tp1) trade.tp1Hit = true;
                    if (trade.currentPrice <= trade.tp2) trade.tp2Hit = true;
                    if (trade.currentPrice <= trade.tp3) trade.tp3Hit = true;
                    if (trade.currentPrice >= trade.sl) trade.slHit = true;
                }
            }
        } catch (e) {
            console.error(`Failed to update price for ${trade.symbol}:`, e);
        }
    }
    
    saveTrades();
    updateTradeList();
}

function updateTradeList() {
    const el = document.getElementById('activeList');
    document.getElementById('activeCount').textContent = STATE.trades.length;
    
    if (STATE.trades.length === 0) {
        el.innerHTML = '<div style="text-align:center;color:var(--text3);font-size:12px;padding:8px">No active trades</div>';
        return;
    }
    
    el.innerHTML = STATE.trades.map(trade => {
        const pnl = trade.direction === 'LONG' 
            ? ((trade.currentPrice - trade.entry) / trade.entry) * 100
            : ((trade.entry - trade.currentPrice) / trade.entry) * 100;
        
        const pnlClass = pnl >= 0 ? 'profit' : 'loss';
        
        return `
            <div class="active-card ${trade.direction.toLowerCase()}">
                <div class="active-top">
                    <div class="active-pair">
                        ${trade.symbol.replace('USDT', '')}
                        <span class="dir-tag ${trade.direction.toLowerCase()}">${trade.direction}</span>
                    </div>
                    <span class="active-pnl ${pnlClass}">${pnl >= 0 ? '+' : ''}${pnl.toFixed(2)}%</span>
                </div>
                <div class="active-levels">
                    <div class="active-level">
                        <div class="active-level-label">Entry</div>
                        <div class="active-level-value" style="color:var(--cyan)">$${fmtPrice(trade.entry)}</div>
                    </div>
                    <div class="active-level ${trade.slHit ? 'stopped' : ''}">
                        <div class="active-level-label">SL</div>
                        <div class="active-level-value" style="color:var(--short)">$${fmtPrice(trade.sl)}</div>
                    </div>
                    <div class="active-level ${trade.tp1Hit ? 'hit' : ''}">
                        <div class="active-level-label">TP1</div>
                        <div class="active-level-value" style="color:var(--long)">$${fmtPrice(trade.tp1)}</div>
                    </div>
                    <div class="active-level ${trade.tp2Hit ? 'hit' : ''}">
                        <div class="active-level-label">TP2</div>
                        <div class="active-level-value" style="color:var(--long)">$${fmtPrice(trade.tp2)}</div>
                    </div>
                    <div class="active-level ${trade.tp3Hit ? 'hit' : ''}">
                        <div class="active-level-label">TP3</div>
                        <div class="active-level-value" style="color:var(--long)">$${fmtPrice(trade.tp3)}</div>
                    </div>
                </div>
                <div class="active-meta">
                    <span>${trade.grade} ‚Ä¢ ${trade.tf} ‚Ä¢ R:R 1:${trade.rr}</span>
                    <button class="close-btn" onclick="closeTrade(${trade.id})">‚úï Close</button>
                </div>
            </div>
        `;
    }).join('');
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// EVENT HANDLERS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function selectSignal(idx) {
    STATE.selected = idx;
    STATE.current = JSON.parse(JSON.stringify(STATE.signals[idx]));
    STATE.aiResult = null;
    
    updateSignalList();
    updateMainPanel();
}

function toggleScan() {
    STATE.scanning = !STATE.scanning;
    
    const btn = document.getElementById('scanBtn');
    const icon = document.getElementById('scanIcon');
    
    if (STATE.scanning) {
        btn.className = 'btn scanning';
        icon.textContent = '‚óâ';
        resetScanProgress(); // Show rainbow progress bar immediately
        runScanner();
    } else {
        btn.className = 'btn';
        icon.textContent = '‚óè';
    }
}

function setMode(mode) {
    STATE.mode = mode;
    STATE.selected = null;
    STATE.current = null;
    STATE.aiResult = null;
    
    document.getElementById('modeAll').className = 'mode-btn' + (mode === 'ALL' ? ' active' : '');
    document.getElementById('modeScalp').className = 'mode-btn' + (mode === 'SCALP' ? ' active' : '');
    document.getElementById('modeSwing').className = 'mode-btn' + (mode === 'SWING' ? ' active' : '');
    
    updateSignalList();
    updateCounts();
    updateMainPanel();
}

function setFilter(filter) {
    STATE.filter = filter;
    
    document.getElementById('filterAll').className = 'filter-btn' + (filter === 'all' ? ' active' : '');
    document.getElementById('filterPerfect').className = 'filter-btn' + (filter === 'perfect' ? ' active' : '');
    document.getElementById('filterReady').className = 'filter-btn' + (filter === 'ready' ? ' active' : '');
    document.getElementById('filterEarly').className = 'filter-btn' + (filter === 'early' ? ' active' : '');
    
    updateSignalList();
}

async function askAI() {
    console.log('ü§ñ askAI() called');
    
    if (!STATE.current) {
        console.warn('‚ö†Ô∏è No signal selected');
        toast('Select a signal first!', 'error');
        return;
    }
    
    console.log('üìä Current signal:', STATE.current.symbol, STATE.current.tf);
    
    if (!STATE.aiKey) {
        console.warn('‚ö†Ô∏è No API key configured');
        toast('Configure API key in Settings!', 'warning');
        showSettings();
        return;
    }
    
    console.log('üîë API Key present:', STATE.aiKey.substring(0, 15) + '...');
    toast('üß† Multi-AI Analyzing...', 'warning');
    
    try {
        const result = await getAIAnalysis(STATE.current);
        console.log('üì¶ AI Result:', result);
        
        if (result) {
            STATE.aiResult = result;
            STATE.aiExpanded = false; // Start collapsed
            updateMainPanel();
            
            document.getElementById('aiDot').className = 'ai-dot on';
            document.getElementById('aiStatus').textContent = 'AI: ' + result.verdict;
            
            toast(`${result.aiProvider || 'AI'}: ${result.verdict} (${result.confidence}%)`, 'success');
        } else {
            console.error('‚ùå AI result is null');
            toast('AI analysis failed', 'error');
        }
    } catch (error) {
        console.error('‚ùå askAI error:', error);
        toast('AI error: ' + error.message, 'error');
    }
}

function toggleAIExpand() {
    STATE.aiExpanded = !STATE.aiExpanded;
    const content = document.getElementById('aiExpandedContent');
    if (content) {
        content.style.display = STATE.aiExpanded ? 'block' : 'none';
    }
    updateMainPanel();
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// SETTINGS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function showSettings() {
    document.getElementById('settingsModal').className = 'modal-bg show';
    document.getElementById('apiKeyInput').value = STATE.aiKey;
    document.getElementById('aiModelSelect').value = STATE.aiModel;
    
    // Load DeepSeek and Gemini keys (v13 Multi-AI)
    document.getElementById('deepseekKeyInput').value = STATE.deepseekKey || '';
    document.getElementById('geminiKeyInput').value = STATE.geminiKey || '';
    
    // Load timeframe toggles
    document.getElementById('tf5m').checked = STATE.tfEnabled['5'];
    document.getElementById('tf15m').checked = STATE.tfEnabled['15'];
    document.getElementById('tf30m').checked = STATE.tfEnabled['30'];
    document.getElementById('tf1h').checked = STATE.tfEnabled['60'];
    document.getElementById('tf4h').checked = STATE.tfEnabled['240'];
    document.getElementById('tf1d').checked = STATE.tfEnabled['D'];
    
    // Load scan interval
    document.getElementById('scanInterval').value = STATE.scanInterval;
    
    // Load alert settings
    document.getElementById('alertSound').checked = STATE.alertSound;
    document.getElementById('alertVibrate').checked = STATE.alertVibrate;
    document.getElementById('alertGrade').value = STATE.alertGrade;
    
    // Load telegram settings
    document.getElementById('telegramEnabled').checked = STATE.telegramEnabled;
    document.getElementById('telegramToken').value = STATE.telegramToken;
    document.getElementById('telegramChatId').value = STATE.telegramChatId;
    
    // Load risk settings
    document.getElementById('riskAccount').value = STATE.riskAccount;
    document.getElementById('riskPercent').value = STATE.riskPercent;
    document.getElementById('riskLeverage').value = STATE.riskLeverage;
    document.getElementById('riskMaxPosition').value = STATE.riskMaxPosition;
    
    // Load weight settings
    document.getElementById('weightZone').value = CONFIG.WEIGHTS.zone * 100;
    document.getElementById('weightSMC').value = CONFIG.WEIGHTS.smc * 100;
    document.getElementById('weightMomentum').value = CONFIG.WEIGHTS.momentum * 100;
    updateWeightDisplay();
    
    // Load theme
    document.getElementById('oledTheme').checked = STATE.oledTheme;
    
    // Render coin manager
    renderCoinManager();
    
    updateKeyStatus();
}

function hideSettings() {
    document.getElementById('settingsModal').className = 'modal-bg';
}

function updateKeyStatus() {
    const el = document.getElementById('keyStatus');
    if (STATE.aiKey && STATE.aiKey.length > 10) {
        el.className = 'key-status valid';
        el.textContent = '‚úÖ API Key configured (' + STATE.aiKey.substring(0, 12) + '...)';
    } else {
        el.className = 'key-status invalid';
        el.textContent = '‚ùå No API Key configured';
    }
}

function toggleKeyVis() {
    const input = document.getElementById('apiKeyInput');
    input.type = input.type === 'password' ? 'text' : 'password';
}

function clearKey() {
    document.getElementById('apiKeyInput').value = DEFAULT_KEY;
    STATE.aiKey = DEFAULT_KEY;
    localStorage.removeItem('bybit_scanner_key');
    updateKeyStatus();
    toast('API Key reset to default', 'warning');
}

async function testKey() {
    const key = document.getElementById('apiKeyInput').value.trim();
    if (!key) {
        toast('Enter an API key first!', 'error');
        return;
    }
    
    STATE.aiKey = key;
    toast('Testing connection...', 'warning');
    
    const result = await callGroqAI('Respond with only: {"status":"OK"}');
    
    if (result) {
        toast('‚úÖ Connection successful!', 'success');
        document.getElementById('aiDot').className = 'ai-dot on';
        document.getElementById('aiStatus').textContent = 'AI: Ready';
        updateKeyStatus();
    } else {
        toast('‚ùå Connection failed', 'error');
    }
}

function saveSettings() {
    console.log('üíæ saveSettings() called');
    
    STATE.aiKey = document.getElementById('apiKeyInput').value.trim();
    STATE.aiModel = document.getElementById('aiModelSelect').value;
    
    // Save DeepSeek and Gemini keys (v13 Multi-AI)
    STATE.deepseekKey = document.getElementById('deepseekKeyInput').value.trim();
    STATE.geminiKey = document.getElementById('geminiKeyInput').value.trim();
    
    console.log('üíæ Keys captured:', {
        groq: STATE.aiKey ? STATE.aiKey.substring(0, 10) + '...' : 'empty',
        deepseek: STATE.deepseekKey ? 'set' : 'empty',
        gemini: STATE.geminiKey ? 'set' : 'empty'
    });
    
    // Update the key arrays with user's keys - SET first slot, not push
    if (STATE.aiKey) GROQ_KEYS[0] = STATE.aiKey;
    if (STATE.deepseekKey) DEEPSEEK_KEYS[0] = STATE.deepseekKey;
    if (STATE.geminiKey) GEMINI_KEYS[0] = STATE.geminiKey;
    
    // Save timeframe toggles
    STATE.tfEnabled['5'] = document.getElementById('tf5m').checked;
    STATE.tfEnabled['15'] = document.getElementById('tf15m').checked;
    STATE.tfEnabled['30'] = document.getElementById('tf30m').checked;
    STATE.tfEnabled['60'] = document.getElementById('tf1h').checked;
    STATE.tfEnabled['240'] = document.getElementById('tf4h').checked;
    STATE.tfEnabled['D'] = document.getElementById('tf1d').checked;
    
    // Save scan interval
    STATE.scanInterval = parseInt(document.getElementById('scanInterval').value);
    
    // Save alert settings
    STATE.alertSound = document.getElementById('alertSound').checked;
    STATE.alertVibrate = document.getElementById('alertVibrate').checked;
    STATE.alertGrade = document.getElementById('alertGrade').value;
    
    // Save telegram settings
    STATE.telegramEnabled = document.getElementById('telegramEnabled').checked;
    STATE.telegramToken = document.getElementById('telegramToken').value.trim();
    STATE.telegramChatId = document.getElementById('telegramChatId').value.trim();
    
    // Save risk settings
    STATE.riskAccount = parseFloat(document.getElementById('riskAccount').value) || 1000;
    STATE.riskPercent = parseFloat(document.getElementById('riskPercent').value) || 2;
    STATE.riskLeverage = parseInt(document.getElementById('riskLeverage').value) || 10;
    STATE.riskMaxPosition = parseFloat(document.getElementById('riskMaxPosition').value) || 500;
    
    // Save weights
    CONFIG.WEIGHTS.zone = parseInt(document.getElementById('weightZone').value) / 100;
    CONFIG.WEIGHTS.smc = parseInt(document.getElementById('weightSMC').value) / 100;
    CONFIG.WEIGHTS.momentum = parseInt(document.getElementById('weightMomentum').value) / 100;
    
    // Save theme
    STATE.oledTheme = document.getElementById('oledTheme').checked;
    applyTheme();
    
    try {
        localStorage.setItem('bybit_scanner_key', STATE.aiKey);
        localStorage.setItem('bybit_scanner_model', STATE.aiModel);
        localStorage.setItem('bybit_scanner_deepseek', STATE.deepseekKey);
        localStorage.setItem('bybit_scanner_gemini', STATE.geminiKey);
        localStorage.setItem('bybit_scanner_tf', JSON.stringify(STATE.tfEnabled));
        localStorage.setItem('bybit_scanner_interval', STATE.scanInterval);
        localStorage.setItem('bybit_scanner_alert_sound', STATE.alertSound);
        localStorage.setItem('bybit_scanner_alert_vibrate', STATE.alertVibrate);
        localStorage.setItem('bybit_scanner_alert_grade', STATE.alertGrade);
        localStorage.setItem('bybit_scanner_telegram_enabled', STATE.telegramEnabled);
        localStorage.setItem('bybit_scanner_telegram_token', STATE.telegramToken);
        localStorage.setItem('bybit_scanner_telegram_chat', STATE.telegramChatId);
        localStorage.setItem('bybit_scanner_risk_account', STATE.riskAccount);
        localStorage.setItem('bybit_scanner_risk_percent', STATE.riskPercent);
        localStorage.setItem('bybit_scanner_risk_leverage', STATE.riskLeverage);
        localStorage.setItem('bybit_scanner_risk_max', STATE.riskMaxPosition);
        localStorage.setItem('bybit_scanner_weights', JSON.stringify(CONFIG.WEIGHTS));
        localStorage.setItem('bybit_scanner_oled', STATE.oledTheme);
        localStorage.setItem('bybit_scanner_coins', JSON.stringify(CONFIG.COINS));
        localStorage.setItem('bybit_scanner_coin_count', STATE.coinCount);
        console.log('üíæ Settings saved to localStorage successfully!');
    } catch (e) {
        console.error('Failed to save settings:', e);
        toast('Failed to save: ' + e.message, 'error');
        return; // Don't close modal if save failed
    }
    
    if (STATE.aiKey || STATE.deepseekKey || STATE.geminiKey) {
        document.getElementById('aiDot').className = 'ai-dot on';
        document.getElementById('aiStatus').textContent = 'AI: Ready';
    }
    
    updateKeyStatus();
    hideSettings();
    toast('Settings saved!', 'success');
}

function loadSettings() {
    try {
        STATE.aiKey = localStorage.getItem('bybit_scanner_key') || DEFAULT_KEY;
        STATE.aiModel = localStorage.getItem('bybit_scanner_model') || 'llama-3.3-70b-versatile';
        
        // Load DeepSeek and Gemini keys (v13 Multi-AI)
        STATE.deepseekKey = localStorage.getItem('bybit_scanner_deepseek') || '';
        STATE.geminiKey = localStorage.getItem('bybit_scanner_gemini') || '';
        
        // Update the key arrays with saved keys - SET first slot
        if (STATE.aiKey) GROQ_KEYS[0] = STATE.aiKey;
        if (STATE.deepseekKey) DEEPSEEK_KEYS[0] = STATE.deepseekKey;
        if (STATE.geminiKey) GEMINI_KEYS[0] = STATE.geminiKey;
        
        console.log('üîë Keys loaded:', {
            groq: STATE.aiKey ? STATE.aiKey.substring(0, 10) + '...' : 'empty',
            deepseek: STATE.deepseekKey ? 'set' : 'empty',
            gemini: STATE.geminiKey ? 'set' : 'empty'
        });
        
        // Load timeframe toggles
        const savedTf = localStorage.getItem('bybit_scanner_tf');
        if (savedTf) {
            STATE.tfEnabled = JSON.parse(savedTf);
        }
        
        // Load scan interval
        const savedInterval = localStorage.getItem('bybit_scanner_interval');
        if (savedInterval) STATE.scanInterval = parseInt(savedInterval);
        
        // Load alert settings
        const savedSound = localStorage.getItem('bybit_scanner_alert_sound');
        const savedVibrate = localStorage.getItem('bybit_scanner_alert_vibrate');
        const savedGrade = localStorage.getItem('bybit_scanner_alert_grade');
        
        if (savedSound !== null) STATE.alertSound = savedSound === 'true';
        if (savedVibrate !== null) STATE.alertVibrate = savedVibrate === 'true';
        if (savedGrade) STATE.alertGrade = savedGrade;
        
        // Load telegram settings
        STATE.telegramEnabled = localStorage.getItem('bybit_scanner_telegram_enabled') === 'true';
        STATE.telegramToken = localStorage.getItem('bybit_scanner_telegram_token') || '';
        STATE.telegramChatId = localStorage.getItem('bybit_scanner_telegram_chat') || '';
        
        // Load risk settings
        STATE.riskAccount = parseFloat(localStorage.getItem('bybit_scanner_risk_account')) || 1000;
        STATE.riskPercent = parseFloat(localStorage.getItem('bybit_scanner_risk_percent')) || 2;
        STATE.riskLeverage = parseInt(localStorage.getItem('bybit_scanner_risk_leverage')) || 10;
        STATE.riskMaxPosition = parseFloat(localStorage.getItem('bybit_scanner_risk_max')) || 500;
        
        // Load weights
        const savedWeights = localStorage.getItem('bybit_scanner_weights');
        if (savedWeights) {
            CONFIG.WEIGHTS = JSON.parse(savedWeights);
        }
        
        // Load theme
        STATE.oledTheme = localStorage.getItem('bybit_scanner_oled') === 'true';
        applyTheme();
        
        // Load coins
        const savedCoins = localStorage.getItem('bybit_scanner_coins');
        const savedCoinCount = localStorage.getItem('bybit_scanner_coin_count');
        if (savedCoins) {
            CONFIG.COINS = JSON.parse(savedCoins);
        } else {
            CONFIG.COINS = CONFIG.ALL_COINS.slice(0, 50);
        }
        if (savedCoinCount) STATE.coinCount = parseInt(savedCoinCount);
        
        if (STATE.aiKey || STATE.deepseekKey || STATE.geminiKey) {
            document.getElementById('aiDot').className = 'ai-dot on';
            document.getElementById('aiStatus').textContent = 'AI: Ready';
        }
    } catch (e) {
        console.error('Failed to load settings:', e);
        STATE.aiKey = DEFAULT_KEY;
        CONFIG.COINS = CONFIG.ALL_COINS.slice(0, 50);
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// ALERT FUNCTIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function triggerAlert(signal) {
    // Play sound
    if (STATE.alertSound) {
        playAlertSound();
    }
    
    // Vibrate
    if (STATE.alertVibrate && navigator.vibrate) {
        navigator.vibrate([200, 100, 200, 100, 200]);
    }
    
    // Send Telegram alert
    if (STATE.telegramEnabled) {
        sendTelegramAlert(signal);
    }
    
    // Show notification toast
    toast(`üîî ${signal.grade}: ${signal.symbol.replace('USDT', '')} ${signal.direction} on ${signal.tf}`, 'success');
}

function playAlertSound() {
    try {
        // Create audio context for alert beep
        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        const oscillator = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();
        
        oscillator.connect(gainNode);
        gainNode.connect(audioCtx.destination);
        
        oscillator.frequency.value = 880; // A5 note
        oscillator.type = 'sine';
        gainNode.gain.value = 0.3;
        
        oscillator.start();
        
        // Beep pattern: beep-beep-beep
        setTimeout(() => { gainNode.gain.value = 0; }, 100);
        setTimeout(() => { gainNode.gain.value = 0.3; }, 150);
        setTimeout(() => { gainNode.gain.value = 0; }, 250);
        setTimeout(() => { gainNode.gain.value = 0.3; }, 300);
        setTimeout(() => { gainNode.gain.value = 0; }, 400);
        setTimeout(() => { oscillator.stop(); }, 450);
    } catch (e) {
        console.log('Audio not supported');
    }
}

function testAlert() {
    const testSignal = {
        symbol: 'BTCUSDT',
        direction: 'LONG',
        grade: 'PERFECT',
        tf: '1H'
    };
    triggerAlert(testSignal);
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// COIN MANAGER FUNCTIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function setCoinCount(count) {
    STATE.coinCount = count;
    CONFIG.COINS = CONFIG.ALL_COINS.slice(0, count);
    renderCoinManager();
    toast(`Set to Top ${count} coins`, 'success');
}

function addCoin() {
    const input = document.getElementById('addCoinInput');
    let coin = input.value.trim().toUpperCase();
    if (!coin) return;
    
    if (!coin.endsWith('USDT')) {
        coin = coin + 'USDT';
    }
    
    if (CONFIG.COINS.includes(coin)) {
        toast('Coin already in list!', 'warning');
        return;
    }
    
    CONFIG.COINS.push(coin);
    input.value = '';
    renderCoinManager();
    toast(`Added ${coin}`, 'success');
}

function removeCoin(coin) {
    CONFIG.COINS = CONFIG.COINS.filter(c => c !== coin);
    renderCoinManager();
}

function renderCoinManager() {
    const el = document.getElementById('coinManager');
    document.getElementById('coinCountDisplay').textContent = CONFIG.COINS.length;
    
    el.innerHTML = `<div class="coin-grid">${CONFIG.COINS.map(coin => `
        <div class="coin-chip">
            <span>${coin.replace('USDT', '')}</span>
            <span class="remove-coin" onclick="removeCoin('${coin}')">√ó</span>
        </div>
    `).join('')}</div>`;
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// WEIGHT & THEME FUNCTIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function updateWeightDisplay() {
    const zone = parseInt(document.getElementById('weightZone').value);
    const smc = parseInt(document.getElementById('weightSMC').value);
    const momentum = parseInt(document.getElementById('weightMomentum').value);
    
    document.getElementById('weightZoneVal').textContent = zone + '%';
    document.getElementById('weightSMCVal').textContent = smc + '%';
    document.getElementById('weightMomentumVal').textContent = momentum + '%';
    
    const total = zone + smc + momentum;
    const totalEl = document.getElementById('weightTotal');
    totalEl.textContent = total + '%';
    totalEl.style.color = total === 100 ? 'var(--long)' : 'var(--short)';
}

function applyTheme() {
    if (STATE.oledTheme) {
        document.body.classList.add('oled');
    } else {
        document.body.classList.remove('oled');
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// TELEGRAM FUNCTIONS
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async function sendTelegramAlert(signal) {
    if (!STATE.telegramEnabled || !STATE.telegramToken || !STATE.telegramChatId) return;
    
    const message = `üö® *${signal.grade} SIGNAL*

üìä *${signal.symbol.replace('USDT', '')}/USDT* - ${signal.direction}
‚è±Ô∏è Timeframe: ${signal.tf}
üìà Score: ${signal.score}/100
üéØ Agreement: ${signal.agreed}/3

üí∞ *Trade Levels:*
‚Ä¢ Entry: $${signal.levels.entry.toFixed(4)}
‚Ä¢ Stop Loss: $${signal.levels.sl.toFixed(4)}
‚Ä¢ TP1: $${signal.levels.tp1.toFixed(4)}
‚Ä¢ TP2: $${signal.levels.tp2.toFixed(4)}
‚Ä¢ TP3: $${signal.levels.tp3.toFixed(4)}

‚öñÔ∏è Risk:Reward = 1:${signal.levels.rr}

_Bybit Scanner v4_`;

    try {
        const url = `https://api.telegram.org/bot${STATE.telegramToken}/sendMessage`;
        await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: STATE.telegramChatId,
                text: message,
                parse_mode: 'Markdown'
            })
        });
    } catch (e) {
        console.error('Telegram send error:', e);
    }
}

async function testTelegram() {
    if (!document.getElementById('telegramToken').value || !document.getElementById('telegramChatId').value) {
        toast('Enter Bot Token and Chat ID first!', 'error');
        return;
    }
    
    const token = document.getElementById('telegramToken').value.trim();
    const chatId = document.getElementById('telegramChatId').value.trim();
    
    try {
        const url = `https://api.telegram.org/bot${token}/sendMessage`;
        const response = await fetch(url, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({
                chat_id: chatId,
                text: '‚úÖ Bybit Scanner connected successfully!\n\nYou will receive trading signals here.',
                parse_mode: 'Markdown'
            })
        });
        
        if (response.ok) {
            toast('‚úÖ Telegram test sent!', 'success');
        } else {
            toast('‚ùå Telegram test failed', 'error');
        }
    } catch (e) {
        toast('‚ùå Telegram connection error', 'error');
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// VIEW TOGGLE & HEAT MAP
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function setView(view) {
    STATE.view = view;
    document.getElementById('viewList').className = 'view-btn' + (view === 'list' ? ' active' : '');
    document.getElementById('viewHeatmap').className = 'view-btn' + (view === 'heatmap' ? ' active' : '');
    
    if (view === 'list') {
        updateSignalList();
    } else {
        renderHeatMap();
    }
}

function renderHeatMap() {
    const el = document.getElementById('signalList');
    const coins = [...new Set(STATE.signals.map(s => s.symbol))].slice(0, 30);
    const tfs = ['5m', '15m', '30m', '1H', '4H', '1D'];
    
    if (coins.length === 0) {
        el.innerHTML = `<div class="empty"><div class="empty-icon">üå°Ô∏è</div><div>No signals for heat map</div></div>`;
        return;
    }
    
    let html = `<div class="heat-map-container"><table class="heat-map-table">
        <thead><tr><th>Coin</th>${tfs.map(tf => `<th>${tf}</th>`).join('')}</tr></thead>
        <tbody>`;
    
    for (const coin of coins) {
        html += `<tr><td class="coin-name">${coin.replace('USDT', '')}</td>`;
        
        for (const tf of tfs) {
            const sig = STATE.signals.find(s => s.symbol === coin && s.tf === tf);
            if (sig) {
                const cellClass = sig.direction.toLowerCase() + (sig.grade === 'PERFECT' ? ' perfect' : '');
                html += `<td onclick="selectSignalByKey('${coin}','${tf}')">
                    <div class="heat-cell ${cellClass}">${sig.score}</div>
                </td>`;
            } else {
                html += `<td><div class="heat-cell none">-</div></td>`;
            }
        }
        html += '</tr>';
    }
    
    html += '</tbody></table></div>';
    el.innerHTML = html;
}

function selectSignalByKey(symbol, tf) {
    const idx = STATE.signals.findIndex(s => s.symbol === symbol && s.tf === tf);
    if (idx >= 0) {
        selectSignal(idx);
        setView('list');
    }
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// RISK CALCULATOR
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

function calculatePositionSize(signal) {
    if (!signal) return null;
    
    const account = STATE.riskAccount;
    const riskPct = STATE.riskPercent / 100;
    const leverage = STATE.riskLeverage;
    const maxPos = STATE.riskMaxPosition;
    
    const riskAmount = account * riskPct;
    const slDistance = Math.abs(signal.levels.entry - signal.levels.sl) / signal.levels.entry;
    
    let positionSize = riskAmount / slDistance;
    positionSize = Math.min(positionSize, maxPos);
    
    const margin = positionSize / leverage;
    
    return {
        positionSize: positionSize.toFixed(2),
        margin: margin.toFixed(2),
        riskAmount: riskAmount.toFixed(2),
        leverage: leverage
    };
}

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// INITIALIZATION
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

async function init() {
    console.log('üöÄ Bybit Scanner Starting...');
    
    // Load saved data
    loadSettings();
    loadTrades();
    updateTradeList();
    
    // Fetch BTC price and all market data
    await fetchBTC();
    await fetchAllMarketData();
    
    // Start auto-refresh
    setInterval(fetchBTC, 30000);
    setInterval(fetchAllMarketData, 60000);  // Update market badges every minute
    setInterval(updateTradePrices, 30000);
    
    // Start scanning
    STATE.scanning = true;
    document.getElementById('scanBtn').className = 'btn scanning';
    document.getElementById('scanIcon').textContent = '‚óâ';
    
    runScanner();
    
    console.log('‚úÖ Bybit Scanner Ready');
}

// Start when DOM is ready
document.addEventListener('DOMContentLoaded', init);

// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
// PWA SERVICE WORKER (Offline Support + Install as App)
// ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

// Register Service Worker for PWA
if ('serviceWorker' in navigator) {
    window.addEventListener('load', () => {
        // Create inline service worker
        const swCode = `
            const CACHE_NAME = 'bs-scanner-v10';
            const urlsToCache = ['/'];
            
            self.addEventListener('install', e => {
                e.waitUntil(caches.open(CACHE_NAME).then(cache => cache.addAll(urlsToCache)));
                self.skipWaiting();
            });
            
            self.addEventListener('fetch', e => {
                e.respondWith(
                    fetch(e.request).catch(() => caches.match(e.request))
                );
            });
            
            self.addEventListener('activate', e => {
                e.waitUntil(clients.claim());
            });
        `;
        
        const blob = new Blob([swCode], { type: 'application/javascript' });
        const swUrl = URL.createObjectURL(blob);
        
        navigator.serviceWorker.register(swUrl).then(reg => {
            console.log('‚úÖ PWA Service Worker registered');
        }).catch(err => {
            console.log('PWA registration skipped (local file)');
        });
    });
}

// PWA Install Prompt
let deferredPrompt;
window.addEventListener('beforeinstallprompt', (e) => {
    e.preventDefault();
    deferredPrompt = e;
    console.log('üì± App can be installed! Use browser menu > Add to Home Screen');
});

</script>
</body>
</html>
